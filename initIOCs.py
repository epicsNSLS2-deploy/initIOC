#!/usr/bin/env python3

"""
Script for auto initialization of IOCs from CONFIGURE file.

This script was taken from the installSynApps set of scripts.
Usage instructions can be found in the README.md file in this repo.

Author: Jakub Wlodek
"""

# imports
import os
import re
import time
import shutil
import subprocess
import argparse
import datetime
import sys
from sys import platform

# Include guard in case user doesn't have tkinter installed but still wants to use the CLI version
WITH_GUI=True
try:
    from tkinter import *
    from tkinter import messagebox
    from tkinter import simpledialog
    import tkinter.scrolledtext as ScrolledText
    from tkinter import font as tkFont
    from tkinter import ttk
    import threading
    import webbrowser
except ImportError:
    WITH_GUI=False


# variables used to allow for printing text to GUI or stdout depending on usage
USING_GUI=False
GUI_TOP_WINDOW=None

# version number
__version__ = "v0.1.0"


#-------------------------------------------------
#-------- CONSTANTS AND REQ. DATA STRUCTS --------
#-------------------------------------------------

# Bash shebang length limit is 127 characters, so we need to make sure we account for that
KERNEL_PATH_LIMIT = 127


# list of currently supported drivers (for template based generation). Also used for dropdown in GUI
supported_drivers = [
    'ADProsilica',
    'ADUVC',
    'ADPointGrey',
    'ADLambda',
    'ADSimDetector',
    'ADMerlin',
    'ADPerkinElmer',
    'ADPilatus',
    'ADSpinnaker',
    'ADAndor3',
    'ADURL',
    'ADPSL',
    'ADEiger',
]


# Tooltip messages for the configuration options
config_tooltips = {
    'IOC_DIR' :         'Top level IOC output directory',
    'TOP_BINARY_DIR' :  'Location of compiled binaries on your system.',
    'PREFIX' :          'Generic prefix added to start of each IOC PV name. Unique portion will be autogenerated',
    'ENGINEER' :        'Engineer deploying the IOCs',
    'HOSTNAME' :        'Hostname of IOC server on which it will be deployed',
    'CA_ADDRESS' :      'Channel access address list IP'
}


# Some default values for generating a temporary CONFIGURE file.
base_configuration = {
    'IOC_DIR' :         '/epics/iocs',
    'TOP_BINARY_DIR' :  '/epics/src',
    'PREFIX' :          'DEVEL1:',
    'ENGINEER' :        'C. Engineer',
    'HOSTNAME' :        'localhost',
    'CA_ADDRESS' :      '127.0.0.255'
}

# Certain drivers don't have their connection parameter as the second element (index 1) in the 
# Config() call. In that case, you must add them to this dictionary, and give the index
# of the camera connection parameter.
connection_parameter_index = {
    'ADUVC' : 2
}

# Certain drivers already include an existing connection parameter environment variable.
# This is no longer required, since CAM-CONNECT is used instead.
existing_connection_parameter = {
    "ADEiger"       : "EIGER_IP",
    "ADAravis"      : "CAMERA_NAME",
    "ADVimba"       : "CAMERA_ID",
    "ADSpinnaker"   : "CAMERA_ID",

}


# List of drivers that don't have connection parameters
no_connection_param_drivers = ['ADSimDetector']


# On windows default to C directory
if platform == 'win32':
    base_configuration['IOC_DIR'] = 'C:' + base_configuration['IOC_DIR']
    base_configuration['TOP_BINARY_DIR'] = 'C:' + base_configuration['TOP_BINARY_DIR']


# External areaDetector plugins
ad_plugins = ['ADCompVision', 'ADPluginBar', 'ADPluginEdge', 'ADPluginDmtx']

#-------------------------------------------------
#------------ INTERNAL DATA MODEL CLASS ----------
#-------------------------------------------------


def initIOC_path_join(path_A, path_B):
    """Function that joins two paths.

    All paths use / instead of \\ for simplicity.
    """

    output_path = path_A
    if not path_A.endswith('/'):
        output_path = output_path + '/'
    if path_B.startswith('/'):
        output_path = output_path + path_B[1:]
    else:
        output_path = output_path + path_B

    if output_path.endswith('/'):
        output_path = output_path[:-1]

    return output_path


class IOCActionManager:

    def __init__(self, ioc_top, binary_location, set_lib_path, use_template, with_deps):

        self.ioc_top            = ioc_top
        self.ioc_top_created    = False
        self.binary_location    = binary_location
        self.binaries_flat      = self.check_binaries_flat()
        self.set_lib_path       = set_lib_path
        self.use_template       = use_template
        self.with_deps          = with_deps
        self.update_mod_paths()


    def check_binaries_flat(self):
        if os.path.exists(initIOC_path_join(self.binary_location, 'support')):
            return False
        return True


    def deployment_info(self, action):
        info = ''
        info = info + '#\n# {} IOC deployed using initIOC {}\n'.format(action.ioc_type, __version__)
        info = info + '# Initial target bundle location: {}\n'.format(self.binary_location)
        if self.use_template:
            info = info + '# IOC generated from: https://github.com/epicsNSLS2-deploy/ioc-template\n'
        else:
            _, _, iocBoot_path = self.find_paths_for_action(action)
            if iocBoot_path is not None:
                info = info + '# IOC generated from: {}\n'.format(iocBoot_path)

        info = info + '#{}\n'.format('-' * 64)
        return info


    def update_mod_paths(self):
        self.binaries_flat = self.check_binaries_flat()
        self.base_path = initIOC_path_join(self.binary_location, 'base')
        if self.binaries_flat:
            self.support_path = self.binary_location
        else:
            self.support_path = initIOC_path_join(self.binary_location, 'support')

        self.areaDetector_path = initIOC_path_join(self.support_path, 'areaDetector')


    def find_paths_for_action(self, action):

        try:
            driver_path = initIOC_path_join(self.areaDetector_path, action.ioc_type)

            # identify the IOCs folder
            for name in os.listdir(driver_path):
                if "ioc" == name or "iocs" == name:
                    driver_path = initIOC_path_join(driver_path, name)
                    break

            # identify the IOC 
            for name in os.listdir(driver_path):
                # Add check to see if NOIOC in name - occasional problems generating ADSimDetector
                if ("IOC" in name or "ioc" in name) and "NOIOC" not in name.upper():
                    driver_path = initIOC_path_join(driver_path, name)
                    break

            # Find the dbd dile
            dbd_path = initIOC_path_join(driver_path, "dbd")
            for name in os.listdir(dbd_path):
                if name.endswith(".dbd"):
                    dbd_path = initIOC_path_join(dbd_path, name)
                    break

            # find the driver executable
            executable_path = initIOC_path_join(driver_path, "bin")
            # There should only be one architecture
            for name in os.listdir(executable_path):
                executable_path = initIOC_path_join(executable_path, name)
                break

            # We look for the executable that ends with App
            for name in os.listdir(executable_path):
                if 'App' in name:
                    executable_path = initIOC_path_join(executable_path, name)
                    break

            iocBoot_path = initIOC_path_join(driver_path, 'iocBoot')
            for dir in os.listdir(iocBoot_path):
                if dir.startswith('ioc') and dir.lower().endswith(action.basename):
                    iocBoot_path = initIOC_path_join(iocBoot_path, dir)
                    break
            return executable_path, dbd_path.split('{}'.format(action.ioc_type))[1][1:], iocBoot_path
        except:
            return None, None, None


    def get_lib_path_for_module(self, module_path, architecture, delimeter):
        bin_loc = initIOC_path_join(module_path, 'bin')
        bin_loc = initIOC_path_join(bin_loc, architecture)
        lib_loc = initIOC_path_join(module_path, 'lib')
        lib_loc = initIOC_path_join(lib_loc, architecture)
        return bin_loc + delimeter + lib_loc + delimeter


    def get_lib_path_str(self, action):
        """Function that generates library path for shared built iocs

        Parameters
        ----------
        action : IOCAction
            ioc action for which we are generating lib path.

        Returns
        ----------
        str
            Library path set in form of str
        """

        lib_path_str = ''
        if platform == "win32":
            delimeter = ';'
            closer = '%PATH%"'
            arch='windows-x64-static'
            
        else:
            arch = 'linux-x86_64'
            delimeter = ':'
            closer = '$LD_LIBRARY_PATH'

        if platform == "win32":
            lib_path_str = lib_path_str + 'SET "PATH='
        else:
            lib_path_str = lib_path_str + 'export LD_LIBRARY_PATH='

        lib_path_str = lib_path_str + self.get_lib_path_for_module(self.base_path, arch, delimeter)

        if os.path.exists(self.support_path) and os.path.isdir(self.support_path):
            for dir in os.listdir(self.support_path):
                mod_path = initIOC_path_join(self.support_path, dir)
                if os.path.isdir(mod_path) and dir != "base" and dir != "areaDetector":
                    lib_path_str = lib_path_str + self.get_lib_path_for_module(mod_path, arch, delimeter)

        if os.path.exists(self.areaDetector_path) and os.path.isdir(self.areaDetector_path):
            for dir in os.listdir(self.areaDetector_path):
                mod_path = initIOC_path_join(self.areaDetector_path, dir)
                if os.path.isdir(mod_path) and (dir == 'ADCore' or dir == 'ADSupport' or dir in ad_plugins or dir == action.ioc_type):
                    lib_path_str = lib_path_str + self.get_lib_path_for_module(mod_path, arch, delimeter)

        lib_path_str = lib_path_str + closer
        return lib_path_str
    

    def initialize_ioc_directory(self):
        if not os.path.exists(os.path.dirname(self.ioc_top)):
            initIOC_print('ERROR - IOC top directory {} could not be created'.format(self.ioc_top))
        else:
            if os.path.exists(self.ioc_top):
                initIOC_print('IOC top directory already exists.\n')
            else:
                try:
                    initIOC_print('Creating IOC directory at {}.\n'.format(self.ioc_top))
                    os.mkdir(self.ioc_top)
                except PermissionError:
                    initIOC_print('ERROR - You do not have permissions to write to specified directory!')
                    return
            self.ioc_top_created = True


    def genertate_st_cmd(self, action, executable_path, st_base_path, dbd_path=None):

        initIOC_print('Generating st.cmd using base file:\n{}'.format(st_base_path))
        ioc_path        = initIOC_path_join(self.ioc_top, action.ioc_name)
        exec_written    = False
        lib_path        = ''
        if self.set_lib_path:
            lib_path  = self.get_lib_path_str(action)
        
        if platform == 'win32':
            # On windows, no shebangs, so st.cmd will always run executable followed by st_base.cmd
            st_exe = open(initIOC_path_join(ioc_path, 'st.cmd'), 'w+')
            st_exe.write('@echo OFF\n\n{}\n\n{} st_base.cmd\n'.format(lib_path, executable_path))
            st_exe.close()
            st = open(initIOC_path_join(ioc_path, "st_base.cmd"), "w+")
            exec_written = True

        elif len(executable_path) > KERNEL_PATH_LIMIT or self.set_lib_path:
            if len(executable_path) > KERNEL_PATH_LIMIT:
                # The path length limit for shebangs (#!/) on linux is usually kernel based and set to 127
                initIOC_print('WARNING - Path to executable exceeds legal bash limit, generating st.cmd and st_base.cmd')
            else:
                # If we want to set LD_LIBRARY_PATH we do that here.
                initIOC_print('Appending library path to start of st.cmd...')
            st_exe = open(initIOC_path_join(ioc_path, 'st.cmd'), 'w+')
            st_exe.write('#!/bin/bash\n\n{}\n\n'.format(lib_path))
            st_exe.write('{} st_base.cmd\n'.format(executable_path))
            st = open(initIOC_path_join(ioc_path, "st_base.cmd"), "w+")
            st_exe.close()
            exec_written = True
        else:
            st = open(initIOC_path_join(ioc_path, "st.cmd"), "w+")

        if not exec_written:
            st.write('#!{}\n\n'.format(executable_path))

        st.write('< envPaths\n\n< unique.cmd\n\nerrlogInit(20000)\n\n')
        if dbd_path is not None:
            dbd_file = initIOC_path_join('$({})'.format(action.ioc_type.upper()), dbd_path)
            st.write('dbLoadDatabase({})\n'.format(dbd_file))

        st_base_fp = open(st_base_path, 'r')

        lines = st_base_fp.readlines()
        for line in lines:
            if line.startswith('#!') or 'unique.cmd' in line or 'envPaths' in line or (line.startswith('#') and not self.with_deps):
                pass
            elif line.startswith('#'):
                st.write(line)
            elif line.startswith('dbLoadDatabase') and dbd_path is not None or line.startswith('errlogInit'):
                pass
            elif 'Config(' in line and action.ioc_type not in no_connection_param_drivers and '$(CAM-CONNECT)' not in line:
                try:
                    temp = line.split(',')
                    index = 1
                    if action.ioc_type in connection_parameter_index.keys():
                        index = connection_parameter_index[action.ioc_type]
                    temp[index] = '"$(CAM-CONNECT)"'
                    updated = temp[0]
                    for i in range(1, len(temp)):
                        updated = updated + ',' + temp[i]
                    st.write(updated)
                except IndexError:
                    initIOC_print('Could not automatically detect camera connection parameter.\n')
                    initIOC_print('Must edit the st.cmd or st_base.cmd manually.\n')
                    st.write(line)
            elif line.startswith('epicsEnvSet'):
                action.add_to_environment(line)
            else:
                st.write(line)

        st_base_fp.close()
        st.close()

        self.grab_additional_env(action, st_base_path)
        os.chmod(initIOC_path_join(ioc_path, "st.cmd"), 0o755)

    
    def grab_additional_env(self, action, st_base_path):
        iocBoot_dir = os.path.dirname(st_base_path)
        st_file = os.path.basename(st_base_path)
        for file in os.listdir(iocBoot_dir):
            if file.startswith('st') and file.endswith('.cmd') and file != st_file:
                fp = open(os.path.join(iocBoot_dir, file), 'r')
                lines = fp.readlines()
                for line in lines:
                    if line.startswith('epicsEnvSet'):
                        action.add_to_environment(line)
                fp.close()


    def generate_unique_cmd(self, action):

        initIOC_print('Generating unique.cmd from detected environment...')
        ioc_path = initIOC_path_join(self.ioc_top, action.ioc_name)
        unique_fp = open(initIOC_path_join(ioc_path, 'unique.cmd'), 'w')

        unique_fp.write('#############################################\n')
        unique_fp.write('# initIOC Auto-Generated Unique File        #\n')
        unique_fp.write('# Generated: {:<31}#\n'.format(str(datetime.datetime.now())))
        if 'ENGINEER' in action.epics_environment.keys():
            unique_fp.write('# Deploying Engineer: {:<22}#\n'.format(action.epics_environment['ENGINEER']))
        unique_fp.write('#############################################\n\n\n')

        unique_fp.write(self.deployment_info(action)+'\n\n')

        for env_var in action.epics_environment.keys():
            write_env_var = True
            if action.ioc_type in existing_connection_parameter.keys():
                if env_var == existing_connection_parameter[action.ioc_type]:
                    write_env_var = False
                elif env_var == 'CAM-CONNECT':
                    unique_fp.write('# {}'.format(existing_connection_parameter[action.ioc_type]))
                    
            if write_env_var:
                unique_fp.write('epicsEnvSet("{}",{}"{}")\n'.format(env_var, ' ' * (32 - len(env_var)), action.epics_environment[env_var]))


        unique_fp.close()


    def get_env_paths_name(self, module):

        if module == 'seq':
            return 'SNCSEQ'
        elif module == 'iocStats':
            return 'DEVIOCSTATS'
        elif module == 'areaDetector':
            return 'AREA_DETECTOR'
        else:
            return module.upper()


    def generate_env_paths(self, action):

        initIOC_print('Generating envPaths based on discovered compiled binaries...')
        ioc_path = initIOC_path_join(self.ioc_top, action.ioc_name)
        envPaths_fp = open(initIOC_path_join(ioc_path, 'envPaths'), 'w')

        arch='linux-x86_64'
        if platform == 'win32':
            arch = 'windows-x64-static'

        envPaths_fp.write('# Path propagated to remaining envPaths (binary bundle location)\nepicsEnvSet("BINARY_TOP", "{}")\n\n'.format(self.binary_location))
        envPaths_fp.write('epicsEnvSet("ARCH", "{}")\n'.format(arch))
        envPaths_fp.write('epicsEnvSet("TOP", "${PWD}")\n')

        base_path = initIOC_path_join('$(BINARY_TOP)', 'base')
        envPaths_fp.write('epicsEnvSet("EPICS_BASE",{}"{}")\n'.format((' ' * 14), base_path))

        support_path = "$(BINARY_TOP)"
        if not self.binaries_flat:
            support_path = initIOC_path_join(support_path, "support")

        envPaths_fp.write('epicsEnvSet("SUPPORT",{}"{}")\n\n'.format((' ' * 17), support_path))
        
        for dir in os.listdir(self.support_path):
            mod_path = initIOC_path_join(self.support_path, dir)
            if os.path.isdir(mod_path) and dir not in ['base', 'configure', 'utils', 'documentation', '.git', 'lib', 'bin']:
                mod_path = initIOC_path_join('$(SUPPORT)', dir)
                envPaths_fp.write('epicsEnvSet("{}",{}"{}")\n'.format(self.get_env_paths_name(dir), ' ' * (24 - len(self.get_env_paths_name(dir))), mod_path))

        envPaths_fp.write('\n')

        for dir in os.listdir(self.areaDetector_path):
            mod_path = initIOC_path_join(self.areaDetector_path, dir)
            if os.path.isdir(mod_path) and dir not in ['configure', 'docs', 'documentation', 'ci', '.git', '']:
                mod_path = initIOC_path_join('$(AREA_DETECTOR)', dir)
                envPaths_fp.write('epicsEnvSet("{}",{}"{}")\n'.format(self.get_env_paths_name(dir), ' ' * (24 - len(self.get_env_paths_name(dir))), mod_path))

        envPaths_fp.close()


    def process_action(self, action):

        if not self.ioc_top_created:
            self.initialize_ioc_directory()

        initIOC_print("-------------------------------------------")
        initIOC_print("Setup process for IOC " + action.ioc_name)
        initIOC_print("-------------------------------------------")

        from_template = self.use_template
        executable_path, dbd_path, iocBoot_path = self.find_paths_for_action(action)
        
        if executable_path is None:
            initIOC_print('ERROR - Could not find binary for {}, skipping...'.format(action.ioc_type))
            initIOC_print('Make sure binary for {} exists at binary path:\n{}'.format(action.ioc_type, self.binary_location))
            return
        elif dbd_path is None or iocBoot_path is None:
            if not from_template:
                initIOC_print('WARNING - Could not find dbd and iocBoot folder, defaulting to use template.')
            from_template = True
        
        if os.path.exists(initIOC_path_join(self.ioc_top, action.ioc_name)):
            initIOC_print('ERROR - IOC with name {} already exists in {}.'.format(action.ioc_name, self.ioc_top))
            return

        if not from_template:
            self.create_ioc_from_bundle(action, executable_path, dbd_path, iocBoot_path)
        else:
            self.create_ioc_from_template(action, executable_path)

        self.create_config_file(action)
        #self.make_ignore_files(action) TODO
        initIOC_print('Done.\n')


    def create_config_file(self, action):

        initIOC_print('Generating config file for use with procServ...')
        ioc_path = initIOC_path_join(self.ioc_top, action.ioc_name)
        config_fp = open(initIOC_path_join(ioc_path, 'config'), 'w')
        config_fp.write('NAME={}\nPORT={}\nUSER=softioc\nHOST={}\n'.format(action.ioc_name, action.ioc_port, action.epics_environment['HOSTNAME']))
        config_fp.close()


    def create_ioc_from_bundle(self, action, executable_path, dbd_path, iocBoot_path):

        initIOC_print('Generating IOC from detected bundle located at: {}'.format(self.binary_location))
        time.sleep(0.3)
        ioc_path = initIOC_path_join(self.ioc_top, action.ioc_name)
        os.mkdir(ioc_path)
        os.mkdir(initIOC_path_join(ioc_path, 'autosave'))

        current_base_len = 0
        current_base = None
        for file in os.listdir(iocBoot_path):
            next = initIOC_path_join(iocBoot_path, file)
            if os.path.isfile(next) and file.startswith('st'):
                fp = open(next, 'r')
                lines = fp.readlines()
                fp.close()
                if len(lines) > current_base_len:
                    current_base = next
                    current_base_len = len(lines)

        if current_base is None:
            initIOC_print('ERROR - Could not fine suitable st_base file. Aborting...')
            return

        self.genertate_st_cmd(action, executable_path, current_base, dbd_path=dbd_path)
        self.generate_unique_cmd(action)
        self.generate_env_paths(action)
        self.grab_dependencies_from_bundle(ioc_path, iocBoot_path, self.with_deps)

    
    def grab_dependencies_from_bundle(self, ioc_path, iocBoot_path, with_optional_deps):

        initIOC_print('Collecting additional iocBoot files from bundle...')
        for file in os.listdir(iocBoot_path):
            target = initIOC_path_join(iocBoot_path, file)
            if os.path.isfile(target):
                if file == 'auto_settings.req':
                    shutil.copyfile(target, initIOC_path_join(ioc_path, file))
                elif with_optional_deps and not file.startswith(('Makefile', 'st', 'test', 'READ', 'dll', 'envPaths')):
                    shutil.copyfile(target, initIOC_path_join(ioc_path, file))


    def create_ioc_from_template(self, action, executable_path):

        ioc_path = initIOC_path_join(self.ioc_top, action.ioc_name)

        # First, clone the template:
        out = subprocess.call(["git", "clone", "--quiet", "https://github.com/epicsNSLS2-deploy/ioc-template", ioc_path])
        if out != 0:
            initIOC_print('ERROR - Failed to clone IOC template, aborting...')
        else:
            initIOC_print('Generating IOC from ioc-template (https://github.com/epicsNSLS2-deploy/ioc-temlpate)')
            os.remove(initIOC_path_join(ioc_path, 'st.cmd'))
            os.remove(initIOC_path_join(ioc_path, 'unique.cmd'))
            os.remove(initIOC_path_join(ioc_path, 'envPaths'))
            os.remove(initIOC_path_join(ioc_path, 'config'))
            startup_scripts = initIOC_path_join(ioc_path, 'startupScripts')
            self.genertate_st_cmd(action, executable_path, initIOC_path_join(startup_scripts, '{}St.cmd'.format(action.basename)))
            self.generate_unique_cmd(action)
            self.generate_env_paths(action)
            
            autosave_file_path = initIOC_path_join(ioc_path, 'autosaveFiles')
            dep_file_path = initIOC_path_join(ioc_path, 'dependancyFiles')
            for file in os.listdir(autosave_file_path):
                if file.startswith(action.basename):
                    shutil.copyfile(initIOC_path_join(autosave_file_path, file), initIOC_path_join(ioc_path, 'auto_settings.req'))
            for file in os.listdir(dep_file_path):
                if file.startswith(action.basename):
                    shutil.copyfile(initIOC_path_join(dep_file_path, file), initIOC_path_join(ioc_path, file.split('{}_'.format(action.basename))))
                    self.fix_macros(initIOC_path_join(ioc_path, file.split('{}_'.format(action.basename))))

            self.cleanup_template(action, ioc_path)


    def fix_macros(self, file_path, action):
        """
        Function that replaces certain macros in given filepath (used primarily for substitution files)

        Parameters
        ----------
        file_path : str
            path to the target file
        """

        os.rename(file_path, file_path + '_OLD')
        old = open(file_path+'_OLD', 'r')
        contents = old.read()
        contents = contents.replace('$(PREFIX)', action.ioc_prefix)
        contents = contents.replace('$(PORT)', action.asyn_port)
        new = open(file_path, 'w')
        new.write(contents)
        old.close()
        new.close()
        os.remove(file_path+'_OLD')


    def cleanup_template(self, action, ioc_path):

        initIOC_print('Performing cleanup for {}'.format(action.ioc_name))
        try:
            if platform == "win32":
                cleanup_script = initIOC_path_join(ioc_path, 'cleanup.bat')
                out = subprocess.call([cleanup_script])
            else:
                cleanup_script = initIOC_path_join(ioc_path, 'cleanup.sh')
                out = subprocess.call(['bash', cleanup_script])

            os.remove(cleanup_script)
        except:
            pass



class IOCAction:
    """
    Helper class that stores information and functions for each IOC in the CONFIGURE file

    Attributes
    ----------
    ioc_type : str
        name of areaDetector driver instance the IOC is linked to ex. ADProsilica
    ioc_name : str
        name of the IOC ex. cam-ps1
    ioc_prefix : str
        Prefix used by the IOC
    asyn_port : str
        asyn port used for outputting NDArrays
    ioc_port : str
        telnet port on which procserver will run the IOC
    connection : str
        Value used to connect to the device ex. IP, serial num. etc.
    ioc_num : int
        Counter that keeps track of which IOC it is

    Methods
    -------
    process(ioc_top : str, bin_loc : str, bin_flat : bool)
        clones ioc-template instance, sets up appropriate st.cmd.
    update_unique(ioc_top : str, bin_loc : str, bin_flat : bool, prefix : str, engineer : str, hostname : str, ca_ip : str)
        Updates unique.cmd file with all of the required configuration options
    update_config(ioc_top : str, hostname : str)
        updates the config file with appropriate options
    fix_env_paths(ioc_top: str, bin_flat : bool)
        fixes the existing envpaths with new locations
    getIOCbin(bin_loc : str, bin_flat : bool)
        finds the path to the binary for the IOC based on binary top location
    cleanup(ioc_top : str)
        runs cleanup.sh script to remove unwanted files in generated IOC.
    """


    def __init__(self, ioc_type, ioc_name, ioc_prefix, asyn_port, ioc_port, connection, ioc_num):
        """Constructor for the IOCAction class

        Parameters
        ----------
        ioc_type : str
            name of areaDetector driver instance the IOC is linked to ex. ADProsilica
        ioc_name : str
            name of the IOC ex. cam-ps1
        ioc_prefix : str
            Prefix used by the IOC
        asyn_port : str
            asyn port used for outputting NDArrays
        ioc_port : str
            telnet port on which procserver will run the IOC
        connection : str
            Value used to connect to the device ex. IP, serial num. etc.
        ioc_num : int
            Counter that keeps track of which IOC it is
        """

        self.epics_environment  = {}
        self.ioc_type           = ioc_type
        self.basename           = ioc_type[2:].lower()
        self.ioc_num            = ioc_num

        # These epics environment variables are set by the user for each IOC
        self.user_entered_env = ['ENGINEER', 'PORT', 'IOC', 'CAM-CONNECT', 'PREFIX', 'CTPREFIX', 'HOSTNAME', 'IOCNAME']
        
        self.asyn_port          = asyn_port
        self.epics_environment['ENGINEER']  = 'NA'
        self.epics_environment['PORT']      = asyn_port
        self.epics_environment['IOC']       = 'ioc{}'.format(ioc_type)
        self.epics_environment['EPICS_CA_AUTO_ADDR_LIST']   = 'NO'
        self.epics_environment['EPICS_CA_ADDR_LIST']        = "NA"
        self.epics_environment['EPICS_CA_MAX_ARRAY_BYTES']  = "6000000" 
        
        self.connection         = connection
        self.epics_environment['CAM-CONNECT'] = connection
        
        self.ioc_prefix         = ioc_prefix
        self.epics_environment['PREFIX']    = "{}{{{}-Cam:{}}}".format(ioc_prefix, ioc_type[2:], ioc_num)
        self.epics_environment['CTPREFIX']  = "{}{{{}-Cam:{}}}".format(ioc_prefix, ioc_type[2:], ioc_num)
        self.epics_environment['HOSTNAME']  = 'NA'
        
        self.ioc_port           = ioc_port
        self.ioc_name           = ioc_name
        self.epics_environment['IOCNAME'] = ioc_name
        self.create_base_environment()


    def create_base_environment(self):
        self.epics_environment['QSIZE']     = 20
        self.epics_environment['NCHANS']    = 2048
        self.epics_environment['HIST_SIZE'] = 4096
        self.epics_environment['XSIZE']     = 1024
        self.epics_environment['YSIZE']     = 1024
        self.epics_environment['NELMT']     = 65536
        self.epics_environment['NDTYPE']    = "Int16"
        self.epics_environment['NDFTVL']    = "Short"
        self.epics_environment['CBUFFS']    = 500


    def add_to_environment(self, line):
        line_s = line.strip()
        line_s = re.sub('"', '', line_s)
        line_s = re.sub(' +', '', line_s)
        line_s = re.sub('epicsEnvSet', '', line_s)
        temp = line_s.split(',')
        if temp[0][1:] not in self.user_entered_env:
            self.epics_environment[temp[0][1:]] = temp[1][:-1]



#-------------------------------------------------
#----------------MAIN SCRIPT FUNCTIONS------------
#-------------------------------------------------


def parse_line_into_action(line, prefix, ioc_num_counter):
    """
    Function that parses a line in the CONFIGURE table into an IOCAction object

    Parameters
    ----------
    line : str
        The line to parse from the table
    ioc_num_counter : int
        the ioc counter
    
    Returns
    -------
    ioc_action : IOCAction
        the IOCAction object that contains information from line or None if it cannot successfully be parsed
    """

    try:
        line = line.strip()
        line = re.sub('\t', ' ', line)
        line = re.sub(' +', ' ', line)
        temp = line.split(' ')
        ioc_action = IOCAction(temp[0], temp[1], prefix, temp[2], temp[3], temp[4], ioc_num_counter)
        return ioc_action
    except IndexError:
        initIOC_print('IOC line could not be parsed, skipping...')
        return None


def read_ioc_config(initial_ioc_number):
    """
    Function for reading the CONFIGURE file. Returns a dictionary of configure options,
    a list of IOCAction instances, and a boolean representing if binaries are flat or not

    Returns
    -------
    ioc_actions : List of IOCAction
        list of IOC actions that need to be performed.
    configuration : dict of str -> str
        Dictionary containing all options read from configure
    bin_flat : bool
        toggle for flat or stacked binary directory structure
    """

    if not os.path.exists("CONFIGURE"):
        
        initIOC_print('\nCONFIGURE file not found, attempting to generate one.')
        if not os.access('.', os.W_OK):
            initIOC_print('ERROR! - Cannot create CONFIGURE file, insufficient permissions.\nAborting...')
            exit()
        try:
            enter_config_info()
            initIOC_print("CONFIGURE file generated. Add IOCs to the table, and rerun initADIOC -p.")
            exit()
        except PermissionError:
            initIOC_print("No write permissions in {}. Exiting...".format(os.getcwd()))
            exit()

    ioc_config_file = open("CONFIGURE", "r")
    ioc_actions = []
    configuration = {}
    ioc_num_counter = 1

    line = ioc_config_file.readline()
    while line:
        if "=" in line and not line.startswith('#') and 'BINARIES_FLAT' not in line:
            line = line.strip()
            split = line.split('=')
            configuration[split[0]] = split[1]
        elif not line.startswith('#') and len(line) > 1:
            ioc_action = parse_line_into_action(line, configuration['PREFIX'], ioc_num_counter + initial_ioc_number - 1)
            if ioc_action is not None:
                ioc_num_counter = ioc_num_counter + 1
                ioc_actions.append(ioc_action)

        line = ioc_config_file.readline()

    ioc_config_file.close()
    return ioc_actions, configuration


def print_start_message():
    """ Function for printing initial message """

    initIOC_print("+----------------------------------------------------------------+")
    initIOC_print("+ initIOCs, Version: " + __version__ +"                                      +")
    initIOC_print("+ Python Version: {}, OS platform: {:<27}+".format(sys.version.split()[0], platform))
    initIOC_print("+ Copyright (c): Brookhaven National Laboratory 2018-2019        +")
    initIOC_print("+ This software comes with NO warranty!                          +")
    initIOC_print("+----------------------------------------------------------------+")
    initIOC_print('')


def print_supported_drivers():
    """ Function that prints list of supported drivers """

    initIOC_print('Supported Drivers:')
    initIOC_print("+-----------------------------+")
    for driver in supported_drivers:
        initIOC_print('+ {}'.format(driver))
    initIOC_print('')


def prompt_for_top_dirs(with_welcome=True):
    ioc_top = ''
    binaries_top = ''
    if with_welcome:
        print_start_message()
        initIOC_print('Welcome to initIOC!')
    valid = False
    while not valid:
        ioc_top        = input('Enter the ioc output location. > ')
        if not os.path.exists(os.path.dirname(ioc_top)):
            initIOC_print('The selected ioc output directory does not exist, please try again.')
        elif os.path.isdir(ioc_top) and not os.access(ioc_top, os.W_OK):
            initIOC_print('The selected output directory exists, but you do not have required permissions.')
        elif not os.access(os.path.dirname(ioc_top), os.W_OK):
            initIOC_print('You do not have permission to generate the IOC output directory.')
        else:
            valid = True
    
    valid = False
    while not valid:
        binaries_top = input('Enter the location of your compiled binaries. > ')
        if not os.path.exists(binaries_top):
            initIOC_print('The selected top binary directory does not exist, please try again.')
        else:
            valid = True

    return ioc_top, binaries_top


def enter_config_info():
    initIOC_print('Please enter all pertinent information.\n')
    ioc_top, bin_top = prompt_for_top_dirs(with_welcome=False)
    configuration = {}
    configuration['IOC_DIR'] = ioc_top
    configuration['TOP_BINARY_DIR'] = bin_top
    configuration['PREFIX']          = input('Enter the IOC Prefix (without the camera specific portion ex. XF:10IDC-BI). > ')
    configuration['HOSTNAME']        = input('Enter the IOC server hostname. > ')
    configuration['ENGINEER']        = input('Enter your name and contact information. > ')
    configuration['CA_ADDRESS']   = input('Enter the Channel Address subnet IP. > ')
    write_config(configuration)


def write_config(configuration):
    if os.path.exists('CONFIGURE'):
        os.remove('CONFIGURE')
    file = open('CONFIGURE', 'w')
    file.write('#\n# initIOCs CONFIGURE file autogenerated on {}\n#\n\n'.format(datetime.datetime.now()))
    for elem in configuration.keys():
        file.write('# {}\n'.format(config_tooltips[elem]))
        file.write('{}={}\n\n'.format(elem, configuration[elem]))

    file.write('# IOC Type        IOC Name     Asyn Port      IOC Port      Cam Connection\n')
    file.write('#-------------------------------------------------------------------------\n')
    file.close()


def guided_init_iocs(initial_ioc_num, manager):
    """ Function that guides the user through generating a single IOC through the CLI """

    ioc_num = initial_ioc_num
    
    prefix          = input('Enter the IOC Prefix (without the camera specific portion ex. XF:10IDC-BI). > ')
    hostname        = input('Enter the IOC server hostname. > ')
    engineer        = input('Enter your name and contact information. > ')
    ca_address_ip   = input('Enter the Channel Address subnet IP. > ')

    another_ioc = True
    while another_ioc:
        driver_type = None
        while driver_type is None:
            driver_type = input('What driver type would you like to generate? > ')
            if driver_type not in supported_drivers and manager.use_template:
                driver_type = None
                initIOC_print('The selected driver does not have a template. See list of supported drivers below.')
                print_supported_drivers()
                initIOC_print('You may alternatively try run from sources (without the -t flag).')
            if driver_type is not None and not os.path.exists(os.path.join(manager.areaDetector_path, driver_type)):
                initIOC_print('Could not find driver {} in {}.'.format(driver_type, os.path.join(manager.areaDetector_path, driver_type)))
                driver_type = None
        ioc_name = input('What should the IOC name be? > ')
        asyn_port = input('What asyn port should the IOC use? (ex. PS1). > ')
        ioc_port = input('What telnet port should procServer use to run the IOC? > ')
        connection = input('Enter the connection param for your device. (ex. IP, serial number etc.) enter NA if not sure. > ')
        ioc_action = IOCAction(driver_type, ioc_name, prefix, asyn_port, ioc_port, connection, ioc_num)
        ioc_action.epics_environment['HOSTNAME'] = hostname
        ioc_action.epics_environment['ENGINEER'] = engineer
        ioc_action.epics_environment['EPICS_CA_ADDR_LIST'] = ca_address_ip
        manager.process_action(ioc_action)
        another = input('Would you like to generate another IOC? (y/n). > ')
        if another != 'y':
            another_ioc = False
            ioc_num = ioc_num + 1
    initIOC_print('Exiting...')


def init_iocs_cli(initial_ioc_number, actions, manager):
    """
    Main driver function. First calls read_ioc_config, then for each instance of IOCAction
    perform the process, update_unique, update_config, fix_env_paths, and cleanup functions
    """

    if len(actions) == 0:
        initIOC_print('No IOCs detected in table.')
    for action in actions:
        if action.ioc_type not in supported_drivers and manager.use_template:
            initIOC_print('ERROR - {} does not currently have a template!'.format(action.ioc_type))
            print_supported_drivers()
            initIOC_print('To request support for {} to be added to initIOC, please create an issue on:'.format(action.ioc_type))
            initIOC_print('https://github.com/epicsNSLS2-deploy/initIOC/issues\n')
            initIOC_print('Alternatively, you may try using the non-templated version.')
        else:
            manager.process_action(action)


def initIOC_print(text):
    """
    A wrapper function for 'print' that allows for printing to CLI or to log
    """

    if USING_GUI and GUI_TOP_WINDOW is not None:
        GUI_TOP_WINDOW.writeToLog(text + '\n')
    else:
        print(text)


#-------------------------------------------------
#---------------- MAIN GUI CLASSES ---------------
#-------------------------------------------------


class ToolTip(object):
    """
    Class for handling tool tips in the initIOC GUI.

    Attributes
    ----------
    widget : tkinter widget
        target widget for which to display tooltip
    tipwindow : window
        tooltip window
    id : int
        id number
    x, y : int
        coordinates of the tooltip
    """

    # Written by Michael Posada

    def __init__(self, widget):
        """ Constructor for ToolTip class """

        self.widget = widget
        self.tipwindow = None
        self.id = None
        self.x = 0
        self.y = 0

    def showtip(self, text):
        """ Function that actually displays the tooltip """

        self.text = text
        if self.tipwindow or not self.text:
            return
        x, y, cx, cy = self.widget.bbox("insert")
        x = x + self.widget.winfo_rootx() + 57
        y = y + cy + self.widget.winfo_rooty() +27
        self.tipwindow = tw = Toplevel(self.widget)
        tw.wm_overrideredirect(1)
        tw.wm_geometry("+%d+%d" % (x, y))
        label = Label(tw, text=self.text, justify=LEFT,
                      background="#ffffe0", relief=SOLID, borderwidth=1,
                      font=("tahoma", "8", "normal"))
        label.pack(ipadx=1)

    def hidetip(self):
        """ Function that destroys the tooltip """

        tw = self.tipwindow
        self.tipwindow = None
        if tw:
            tw.destroy()


def CreateToolTip(widget, text):
    """
    Function that binds the tooltip to a widget

    Parameters
    ----------
    widget : tkinter widget
        widget to bind to
    text : str
        tooltip text
    """

    toolTip = ToolTip(widget)
    def enter(event):
        toolTip.showtip(text)
    def leave(event):
        toolTip.hidetip()
    widget.bind('<Enter>', enter)
    widget.bind('<Leave>', leave)


class InitIOCGui:
    """
    Class representing the main GUI for initIOCs.

    Attributes
    ----------
    master : Tk window
        the containing window
    frame : tk frame
        the main frame
    ioc_num_counter : int
        counter for number of IOCs deployed.
    actions, configuration, bin_flat : list of IOCAction, dict of {str,str}, bool
        configuration of IOCs to generate

    Methods
    -------
    initWindow()
        initializes the window
    writeToIOCPanel()
        writes to the ioc panel
    readGUIConfig()
        parses gui data into actions, configuration, binflat
    execute()
        executes the ioc actions
    save()
        saves the IOC configuration
    openAddIOCWindow()
        opens window to add new IOC
    """

    def __init__(self, master, initial_ioc_number, configuration, actions, manager):
        """ Constructor for InitIOCGui """

        self.master = master
        self.initial_ioc_number = initial_ioc_number
        self.configuration = configuration
        self.manager = manager

        self.master.protocol('WM_DELETE_WINDOW', self.thread_cleanup)
        self.frame = Frame(self.master)
        self.frame.pack()

        self.largeFont = tkFont.Font(size = 12)
        self.largeFontU = tkFont.Font(size = 12)
        self.largeFontU.configure(underline = True)

        self.showPopups = BooleanVar()
        self.showPopups.set(True)
        self.askAnother = BooleanVar()
        self.askAnother.set(False)

        self.ioc_num_counter = 0
        self.executionThread = threading.Thread()

        menubar = Menu(self.master)

        filemenu = Menu(menubar, tearoff=0)
        filemenu.add_command(label='Save Configuration',    command=self.save)
        filemenu.add_command(label='Save Log',              command=self.saveLog)
        filemenu.add_command(label='Clear Log',             command=self.clearLog)
        filemenu.add_command(label='Exit',                  command=self.thread_cleanup)
        menubar.add_cascade(label='File', menu=filemenu)

        editmenu = Menu(menubar, tearoff=0)
        editmenu.add_command(label='Add IOC',           command=self.openAddIOCWindow)
        editmenu.add_command(label='Clear IOC table',   command=self.initIOCPanel)
        editmenu.add_checkbutton(label='Toggle Popups',             onvalue=True, offvalue=False, variable=self.showPopups)
        editmenu.add_checkbutton(label='Ask to Add Multiple IOCs',  onvalue=True, offvalue=False, variable=self.askAnother)
        menubar.add_cascade(label='Edit', menu=editmenu)

        runmenu = Menu(menubar, tearoff=0)
        runmenu.add_command(label='Generate IOCs', command=self.execute)
        menubar.add_cascade(label='Run', menu=runmenu)

        helpmenu = Menu(menubar, tearoff=0)
        helpmenu.add_command(label='Online Docs',       command=lambda: webbrowser.open('https://epicsnsls2-deploy.github.io/Deploy-Docs/#initIOC-step-by-step-example', new=2))
        helpmenu.add_command(label='initIOC on Github', command = lambda: webbrowser.open('https://github.com/epicsNSLS2-deploy/initIOC', new=2))
        helpmenu.add_command(label='Report an Issue',   command = lambda: webbrowser.open('https://github.com/epicsNSLS2-deploy/initIOC/issues', new=2))
        helpmenu.add_command(label='Supported Drivers', command=print_supported_drivers)
        helpmenu.add_command(label = 'About',           command=print_start_message)
        menubar.add_cascade(label='Help', menu=helpmenu)

        self.master.config(menu=menubar)

        # Read initial configuration from save file
        self.actions = actions

        # User inputs for all configuration options
        self.text_inputs = {}
        row_counter = 0

        for elem in self.configuration.keys():
            self.text_inputs[elem] = StringVar()
            elem_label=Label(self.frame, text=elem).grid(row=row_counter, column=0, padx = 10, pady = 10)
            elem_entry = Entry(self.frame, textvariable=self.text_inputs[elem], width=30)
            elem_entry.grid(row=row_counter, column=1, columnspan = 2, padx=10, pady=10)
            elem_entry.insert(0, self.configuration[elem])
            CreateToolTip(elem_entry, config_tooltips[elem])
            row_counter = row_counter + 1

        self.master.title('initIOC GUI')

        ttk.Separator(self.frame, orient=HORIZONTAL).grid(row=row_counter, columnspan=3, padx = 5, sticky = 'ew')

        Label(self.frame, text='IOC Generation Table - You may edit this table manually, or add new IOCs with the Add Button').grid(row = 0, column = 3, columnspan = 5, padx = 10, pady = 10)
        self.iocPanel = ScrolledText.ScrolledText(self.frame, width = '75', height = '15')
        self.iocPanel.grid(row = 1, column = 3, padx = 15, pady = 15, columnspan = 5, rowspan = row_counter + 1)
        self.initIOCPanel()
        for action in self.actions:
            self.writeToIOCPanel(action.ioc_type, action.ioc_name, action.asyn_port, action.ioc_port, action.connection)

        Label(self.frame, text='Log', font=self.largeFontU).grid(row = row_counter + 1, column = 0, padx = 5, pady = 0)
        self.logPanel = ScrolledText.ScrolledText(self.frame, width='100', height = '15')
        self.logPanel.grid(row = row_counter + 2, column = 0, rowspan = 5, columnspan = 4, padx = 10, pady = 10)

        saveButton  = Button(self.frame, text="Save",     font=self.largeFont, command=self.save,                height='3', width='20')
        runButton   = Button(self.frame, text="Run",      font=self.largeFont, command=self.execute,             height='3', width='20')
        addButton   = Button(self.frame, text="Add IOC",  font=self.largeFont, command=self.openAddIOCWindow,    height='3', width='20')
        saveButton.grid(row=row_counter+3, column=5, columnspan=2, padx=5, pady=5)
        runButton.grid( row=row_counter+4, column=5, columnspan=2, padx=5, pady=5)
        addButton.grid( row=row_counter+5, column=5, columnspan=2, padx=5, pady=5)


    def initIOCPanel(self):
        """ Function that resets the IOC panel """

        self.iocPanel.delete('1.0', END)
        self.iocPanel.insert(INSERT, '# IOC Type        IOC Name     Asyn Port      IOC Port      Cam Connection\n')
        self.iocPanel.insert(INSERT, '#-------------------------------------------------------------------------\n')


    def writeToIOCPanel(self, ioc_type, name, asyn, port, connect):
        """ Function that writes to the iocPanel """

        self.iocPanel.insert(INSERT, '{:<18}{:<15}{:<15}{:<12}{}\n'.format(ioc_type, name, asyn, port, connect))


    def writeToLog(self, text):
        """ Function that writes text to the GUI log """

        self.logPanel.insert(INSERT, text)
        self.logPanel.see(END)


    def showError(self, text):

        if self.showPopups.get():
            messagebox.showerror('ERROR', text)
        self.writeToLog('ERROR - ' + text + '\n')


    def showWarning(self, text):

        if self.showPopups.get():
            messagebox.showerror('WARNING', text)
        self.writeToLog('WARNING - ' + text + '\n')


    def showMessage(self, text):

        if self.showPopups.get():
            messagebox.showerror('Info', text)
        self.writeToLog(text + '\n')


    def read_gui_config(self):
        """ Function that reads values entered into gui into actions, configuration, and bin_flat """

        for elem in self.text_inputs.keys():
            if self.text_inputs[elem].get() != self.configuration[elem]:
                self.configuration[elem] = self.text_inputs[elem].get()
        
        self.manager.ioc_top = self.configuration['IOC_DIR']
        self.manager.binary_location = self.configuration['TOP_BINARY_DIR']

        self.manager.binaries_flat = self.manager.check_binaries_flat()

        self.manager.update_mod_paths()

        del self.actions[:]
        for line in self.iocPanel.get('1.0', END).splitlines():
            if not line.startswith('#') and len(line) > 1:
                action = parse_line_into_action(line, self.configuration['PREFIX'], self.ioc_num_counter + self.initial_ioc_number)
                action.epics_environment['HOSTNAME'] = self.configuration['HOSTNAME']
                action.epics_environment['ENGINEER'] = self.configuration['ENGINEER']
                action.epics_environment['EPICS_CA_ADDR_LIST'] = self.configuration['CA_ADDRESS']
                if action is not None:
                    self.actions.append(action)
                    self.ioc_num_counter = self.ioc_num_counter + 1
                else:
                    self.showWarning('Could not parse one of the IOC lines entered into the table.')


    def execute(self):
        """ Reads gui info, and runs init_iocs """

        if self.executionThread.is_alive():
            self.showError('Process thread is already active!')
        else:
           self.read_gui_config()
           self.executionThread = threading.Thread(target=lambda : init_iocs_cli(self.initial_ioc_number + self.ioc_num_counter, self.actions, self.manager))
           self.executionThread.start()


    def save(self):
        """ Saves the current IOC configuration """

        self.read_gui_config()
        if os.path.exists('CONFIGURE'):
            os.remove('CONFIGURE')
        file = open('CONFIGURE', 'w')
        file.write('#\n# initIOCs CONFIGURE file autogenerated on {}\n#\n\n'.format(datetime.datetime.now()))
        for elem in self.configuration.keys():
            file.write('# {}\n'.format(config_tooltips[elem]))
            file.write('{}={}\n\n'.format(elem, self.configuration[elem]))

        file.write(self.iocPanel.get('1.0', END))
        initIOC_print('Saved configuration to CONFIGURE file.')


    def saveLog(self):
        """ Function that saves the current log into a log file """

        if not os.path.exists('logs'):
            os.mkdir('logs')
        elif not os.path.isdir('logs'):
            self.showError('logs directory could not be created, logs file exists')
        stamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
        log = open('logs/initIOC-{}.log'.format(stamp), 'w')
        log.write(self.logPanel.get('1.0', END))
        log.close()
        self.writeToLog('Wrote log file.\n')


    def clearLog(self):
        """ Reinitializes the log """

        self.logPanel.delete('1.0', END)
        print_start_message()


    def openAddIOCWindow(self):
        """ Opens an addIOC window """

        AddIOCWindow(self)


    def thread_cleanup(self):
        if self.executionThread.is_alive():
            self.executionThread.join()
        self.master.destroy()


class AddIOCWindow:
    """
    Class representing a window for adding a new IOC into the config
    """

    def __init__(self, root):

        self.root = root
        self.master = Toplevel()
        self.master.title('Add New IOC')

        # Create the entry fields for all the paramters
        self.ioc_type_var       = StringVar()
        self.ioc_type_var.set(supported_drivers[0])

        self.ioc_name_var       = StringVar()
        self.asyn_port_var      = StringVar()
        self.ioc_port_var       = StringVar()
        self.cam_connect_var    = StringVar()

        # TODO: Change this IOC type to a dropdown menu.
        ioc_type_label      = Label(self.master, text="IOC Type").grid(row = 0, column = 0, padx = 10, pady = 10)
        ioc_type_entry      = ttk.Combobox(self.master, textvariable=self.ioc_type_var, values=supported_drivers)
        ioc_type_entry.grid(row = 0, column = 1, columnspan=2, padx = 10, pady = 10)
        CreateToolTip(ioc_type_entry, 'The IOC type. Must be from list of supported drivers.')

        ioc_name_label      = Label(self.master, text="IOC Name").grid(row = 1, column = 0, padx = 10, pady = 10)
        ioc_name_entry      = Entry(self.master, textvariable=self.ioc_name_var)
        ioc_name_entry.grid(row = 1, column = 1, columnspan=2, padx = 10, pady = 10)
        CreateToolTip(ioc_name_entry, 'The name of the IOC. Usually cam-$NAME')

        asyn_port_label     = Label(self.master, text="Asyn Port").grid(row = 2, column = 0, padx = 10, pady = 10)
        asyn_port_entry     = Entry(self.master, textvariable=self.asyn_port_var)
        asyn_port_entry.grid(row = 2, column = 1, columnspan=2, padx = 10, pady = 10)
        CreateToolTip(asyn_port_entry, 'IOC Asyn port. Usually Shorthand of IOC type and number. ex. SIM1')

        ioc_port_label      = Label(self.master, text="IOC Port").grid(row = 3, column = 0, padx = 10, pady = 10)
        ioc_port_entry      = Entry(self.master, textvariable=self.ioc_port_var)
        ioc_port_entry.grid(row = 3, column = 1, columnspan=2, padx = 10, pady = 10)
        CreateToolTip(ioc_port_entry, 'Telnet port used by softioc when running the IOC')

        cam_connect_label   = Label(self.master, text="Cam Connection").grid(row = 4, column = 0, padx = 10, pady = 10)
        cam_connect_entry   = Entry(self.master, textvariable=self.cam_connect_var)
        cam_connect_entry.grid(row = 4, column = 1, columnspan=2, padx = 10, pady = 10)
        CreateToolTip(cam_connect_entry, 'A general parameter used to connect to camera. Typically IP, Serial #, config path, etc.')

        Button(self.master,text="Submit", command=self.submit).grid(row = 5, column = 0, padx = 10, pady = 10)
        Button(self.master,text="Cancel", command=self.master.destroy).grid(row = 5, column = 2, padx = 10, pady = 10)


    def submit(self):
        """ Function that enters the filled IOC values into the configuration """

        if self.ioc_type_var.get() not in supported_drivers:
            self.root.showError('The selected IOC type is not supported.')
            self.master.destroy()
            return

        ioc_type = self.ioc_type_var.get()
        name = self.ioc_name_var.get()
        asyn = self.asyn_port_var.get()
        port = self.ioc_port_var.get()
        connect = self.cam_connect_var.get()
        if ioc_type == '' or name == '' or asyn == '' or port == '' or connect == '':
            self.root.showError('Please enter a valid value for all of the fields.')
            return

        self.root.writeToIOCPanel(ioc_type, name, asyn, port, connect)
        self.root.writeToLog('Added IOC {} to configuration.\n'.format(name))

        if self.root.askAnother.get():
            res = messagebox.askyesno('Continue', 'Would you like to add another IOC?')
            if res is not None and not res:
                self.master.destroy()
            elif res is not None:
                self.ioc_name_var.set('')
                self.ioc_type_var.set('')
                self.ioc_port_var.set('')
                self.asyn_port_var.set('')
                self.cam_connect_var.set('')
        else:
            self.master.destroy()




def parse_args():
    """ Main driver function that parses the command line arguments """

    parser = argparse.ArgumentParser(description='A script for auto-initializing areaDetector IOCs. Edit the CONFIGURE file and run without arguments for default operation.')

    parser.add_argument('-p', '--parseconfigure',   action='store_true', help='Add this flag to use a run initIOCs given a CONFIGURE file.')
    parser.add_argument('-g', '--gui',              action='store_true', help='Add this flag to enable the GUI version of initIOC.')
    parser.add_argument('-l', '--setlibrarypath',   action='store_true', help='This flag should be added to set library path before startup script is run.')
    parser.add_argument('-t', '--template',         action='store_true', help='This flag will tell initIOC to use an st.cmd template. These are more likely to process without error, but may be somewhat out of date.')
    parser.add_argument('-c', '--clean',            action='store_true', help='This flag specifies if initIOC should attempt to generate a minimal IOC. May result in some missing files that will need manual tweaks.')
    # TODO
    parser.add_argument('-s', '--searchbundle',     help='Add this flag, followed by a path to a binary bundle to get a list of driver executables that are included.')
    #parser.add_argument('-r', '--readioc',          help='When this flag is active, an existing IOC is parsed into a CONFIGURE file, which can be tweaked to generate new IOCs for the same device.')
    parser.add_argument('-n', '--number',           help='Add this flag followed by a number to set an initial value for the IOC counter')
    arguments = vars(parser.parse_args())
    return arguments


# Run the script
def main():
    
    arguments = parse_args()
    initial_num = 1
    if arguments['number'] is not None:
        initial_num = int(arguments['number'])

    global USING_GUI
    global GUI_TOP_WINDOW

    if arguments['searchbundle'] is not None:
        initIOC_print('\nSearching for driver executables...\n')
        bin_top = arguments['searchbundle']
        if not os.path.exists(bin_top):
            initIOC_print('Selected bundle location does not exist.')
        else:
            initIOC_print('Bundle selected: {}'.format(bin_top))
            initIOC_print('List of detected driver executables:\n+-----------------------------------------------')
            manager= IOCActionManager('.', bin_top, False, False, False)
            for dir in os.listdir(manager.areaDetector_path):
                if os.path.isdir(os.path.join(manager.areaDetector_path, dir)):
                    action = IOCAction(dir, '', '', '', '', '', 0)
                    bin_path, db_path, ioc_boot_path = manager.find_paths_for_action(action)
                    if bin_path is not None:
                        initIOC_print('+ {:<16} -   {}'.format(dir, bin_path))
        initIOC_print('')
        exit()

    if arguments['parseconfigure'] or arguments['gui']:
        actions, configuration = read_ioc_config(initial_num)
        manager = IOCActionManager(configuration['IOC_DIR'], configuration['TOP_BINARY_DIR'], arguments['setlibrarypath'], arguments['template'], not arguments['clean'])
        for action in actions:
            action.epics_environment['ENGINEER'] = configuration['ENGINEER']
            action.epics_environment['HOSTNAME'] = configuration['HOSTNAME']
            action.epics_environment['EPICS_CA_ADDR_LIST'] = configuration['CA_ADDRESS']
        if arguments['gui']:
            if not WITH_GUI:
                initIOC_print('ERROR - TKinter GUI package not installed. Please intall and rerun.')
                exit()
            else:
                root = Tk()
                USING_GUI = True
                app = InitIOCGui(root, initial_num, configuration, actions, manager)
                GUI_TOP_WINDOW = app
                print_start_message()
                root.mainloop()
        else:
            print_start_message()
            if len(actions) == 0:
                initIOC_print('No IOCs set for generation, please edit the CONFIGURE file.')
                exit()
            init_iocs_cli(initial_num, actions, manager)
    else:
        ioc_top, bin_top = prompt_for_top_dirs()
        manager = IOCActionManager(ioc_top, bin_top, arguments['setlibrarypath'], arguments['template'], not arguments['clean'])
        guided_init_iocs(initial_num, manager)


if __name__ == '__main__':
    main()





