#!/usr/bin/env python3

"""
Script for auto initialization of IOCs from CONFIGURE file.

This script was taken from the installSynApps set of scripts.
Usage instructions can be found in the README.md file in this repo.

Author: Jakub Wlodek
"""

# imports
import os
import re
import subprocess
import argparse
import datetime
from sys import platform

# Include guard in case user doesn't have tkinter installed but still wants to use the CLI version
WITH_GUI=True
try:
    from tkinter import *
    from tkinter import messagebox
    from tkinter import simpledialog
    import tkinter.scrolledtext as ScrolledText
    from tkinter import font as tkFont
    from tkinter import ttk
    import threading
    import webbrowser
except ImportError:
    WITH_GUI=False


# variables used to allow for printing text to GUI or stdout depending on usage
USING_GUI=False
GUI_TOP_WINDOW=None

# version number
version = "v0.0.5"


#-------------------------------------------------
#-------- CONSTANTS AND REQ. DATA STRUCTS --------
#-------------------------------------------------


KERNEL_PATH_LIMIT = 127

supported_drivers = {
    'ADProsilica',
    'ADUVC',
    'ADPointGrey',
    'ADLambda',
    'ADSimDetector',
    'ADMerlin',
    'ADPerkinElmer',
    'ADPilatus',
    'ADSpinnaker',
    'ADAndor3',
    'ADURL'
}

config_tooltips = {
    'IOC_DIR' : 'Top level IOC output directory',
    'TOP_BINARY_DIR' : 'Location of compiled binaries on your system.',
    'PREFIX' : 'Generic prefix added to start of each IOC PV name. Unique portion will be autogenerated',
    'ENGINEER' : 'Engineer deploying the IOCs',
    'HOSTNAME' : 'Hostname of IOC server on which it will be deployed',
    'CA_ADDRESS' : 'Channel access address list IP'
}


#-------------------------------------------------
#------------ INTERNAL DATA MODEL CLASS ----------
#-------------------------------------------------

class IOCAction:
    """
    Helper class that stores information and functions for each IOC in the CONFIGURE file

    Attributes
    ----------
    ioc_type : str
        name of areaDetector driver instance the IOC is linked to ex. ADProsilica
    ioc_name : str
        name of the IOC ex. cam-ps1
    ioc_prefix : str
        Prefix used by the IOC
    asyn_port : str
        asyn port used for outputting NDArrays
    ioc_port : str
        telnet port on which procserver will run the IOC
    connection : str
        Value used to connect to the device ex. IP, serial num. etc.
    ioc_num : int
        Counter that keeps track of which IOC it is

    Methods
    -------
    process(ioc_top : str, bin_loc : str, bin_flat : bool)
        clones ioc-template instance, sets up appropriate st.cmd.
    update_unique(ioc_top : str, bin_loc : str, bin_flat : bool, prefix : str, engineer : str, hostname : str, ca_ip : str)
        Updates unique.cmd file with all of the required configuration options
    update_config(ioc_top : str, hostname : str)
        updates the config file with appropriate options
    fix_env_paths(ioc_top: str, bin_flat : bool)
        fixes the existing envpaths with new locations
    getIOCbin(bin_loc : str, bin_flat : bool)
        finds the path to the binary for the IOC based on binary top location
    cleanup(ioc_top : str)
        runs cleanup.sh script to remove unwanted files in generated IOC.
    """


    def __init__(self, ioc_type, ioc_name, ioc_prefix, asyn_port, ioc_port, connection, ioc_num):
        """
        Constructor for the IOCAction class

        Parameters
        ----------
        ioc_type : str
            name of areaDetector driver instance the IOC is linked to ex. ADProsilica
        ioc_name : str
            name of the IOC ex. cam-ps1
        ioc_prefix : str
            Prefix used by the IOC
        asyn_port : str
            asyn port used for outputting NDArrays
        ioc_port : str
            telnet port on which procserver will run the IOC
        connection : str
            Value used to connect to the device ex. IP, serial num. etc.
        ioc_num : int
            Counter that keeps track of which IOC it is
        """

        self.ioc_type   = ioc_type
        self.ioc_name   = ioc_name
        self.ioc_prefix = ioc_prefix
        self.asyn_port  = asyn_port
        self.ioc_port   = ioc_port
        self.connection = connection
        self.ioc_num    = ioc_num

    # TODO: Break this function up somewhat into smaller functions
    def process(self, ioc_top, bin_loc, bin_flat):
        """
        Function that clones ioc-template, and pulls correct st.cmd from startupScripts folder
        The binary for the IOC is also identified and inserted into st.cmd

        Parameters
        ----------
        ioc_top : str
            Path to the top directory to contain generated IOCs
        bin_loc : str
            path to top level of binary distribution
        bin_flat : bool
            flag for deciding if binaries are flat or stacked

        Returns
        -------
        int
            0 if success, -1 if error
        """

        initIOC_print("-------------------------------------------")
        initIOC_print("Setup process for IOC " + self.ioc_name)
        initIOC_print("-------------------------------------------")
        if os.path.exists(ioc_top + '/' + self.ioc_name):
            initIOC_print('ERROR - IOC with name {} already exists.'.format(self.ioc_name))
            return -1
        binary_path =  self.getIOCBin(bin_loc, bin_flat) 
        if binary_path is None:
            initIOC_print('ERROR - Could not identify a compiled IOC binary for {}, skipping'.format(self.ioc_type))
            initIOC_print('Make sure that the binary exists and is compiled in the expected location, and make sure BINARIES_FLAT is correct.')
            return -1
        out = subprocess.call(["git", "clone", "--quiet", "https://github.com/epicsNSLS2-deploy/ioc-template", ioc_top + "/" + self.ioc_name])
        if out != 0:
            initIOC_print("Error failed to clone IOC template for ioc {}".format(self.ioc_name))
            return -1
        else:
            initIOC_print("IOC template cloned, converting st.cmd")
            ioc_path = ioc_top +"/" + self.ioc_name
            os.remove(ioc_path+"/st.cmd")

            startup_path = ioc_path+"/startupScripts"
            startup_type = self.ioc_type[2:].lower()

            for file in os.listdir(ioc_path +"/startupScripts"):
                if startup_type in file.lower():
                    startup_path = startup_path + "/" + file
                    break
            
            exe_written = False

            example_st = open(startup_path, "r+")
            if platform =='win32':
                st_exe = open(ioc_path+'/st.cmd', 'w+')
                st_exe.write(binary_path+' st_base.cmd\n')
                st_exe.close()
                st = open(ioc_path+"/st_base.cmd", "w+")
                exe_written = True
            elif len(binary_path) > KERNEL_PATH_LIMIT:     # The path length limit for shebangs (#!/) on linux is usually kernel based and set to 127
                initIOC_print('WARNING - Path to executable exceeds legal bash limit, generating st.cmd and st_base.cmd')
                st_exe = open(ioc_path + '/st.cmd', 'w+')
                st_exe.write(binary_path + ' st_base.cmd\n')
                st = open(ioc_path+"/st_base.cmd", "w+")
                st_exe.close()
                exe_written = True
            else:
                st = open(ioc_path+"/st.cmd", "w+")

            line = example_st.readline()

            while line:
                if "#!" in line:
                    if not exe_written:
                        st.write("#!" + binary_path + "\n")
                elif "envPaths" in line:
                    st.write("< envPaths\n")
                else:
                    st.write(line)

                line = example_st.readline()

            example_st.close()
            st.close()

            autosave_path = ioc_path + "/autosaveFiles"
            autosave_type = self.ioc_type[2:].lower()
            if os.path.exists(autosave_path + "/" + autosave_type + "_auto_settings.req"):
                initIOC_print("Generating auto_settings.req file for IOC {}.".format(self.ioc_name))
                os.rename(autosave_path + "/" + autosave_type + "_auto_settings.req", ioc_path + "/auto_settings.req")
            else:
                initIOC_print("Could not find supported auto_settings.req file for IOC {}.".format(self.ioc_name))

            if os.path.exists(ioc_path + "/dependancyFiles"):
                for file in os.listdir(ioc_path + "/dependancyFiles"):
                    if file.lower().startswith(startup_type):
                        initIOC_print('Copying dependency file {} for {}'.format(file, self.ioc_type))
                        # Copy all required dependency files
                        os.rename(ioc_path + "/dependancyFiles/" + file, ioc_path + "/" + file.split('_', 1)[-1])
                        self.fix_macros(ioc_path + '/' + file.split('_', 1)[-1])

            return 0


    def update_unique(self, ioc_top, bin_loc, bin_flat, prefix, engineer, hostname, ca_ip):
        """
        Function that updates the unique.cmd file with all of the required configurations

        Parameters
        ----------
        ioc_top : str
            Path to the top directory to contain generated IOCs
        bin_loc : str
            path to top level of binary distribution
        bin_flat : bool
            flag for deciding if binaries are flat or stacked
        prefix : str
            Prefix given to the IOC
        engineer : str
            Name of the engineer deploying the IOC
        hostname : str
            name of the host IOC server on which the IOC will run
        ca_ip : str
            Channel Access IP address
        """

        if os.path.exists(ioc_top + "/" + self.ioc_name +"/unique.cmd"):
            initIOC_print("Updating unique file based on configuration")
            unique_path = ioc_top + "/" + self.ioc_name +"/unique.cmd"
            unique_old_path = ioc_top +"/" + self.ioc_name +"/unique_OLD.cmd"
            os.rename(unique_path, unique_old_path)

            uq_old = open(unique_old_path, "r")
            uq = open(unique_path, "w")
            line = uq_old.readline()
            while line:
                if not line.startswith('#'):
                    if "SUPPORT_DIR" in line:
                        if bin_flat:
                            uq.write('epicsEnvSet("SUPPORT_DIR", "{}")\n'.format(bin_loc))
                        else:
                            uq.write('epicsEnvSet("SUPPORT_DIR", "{}")\n'.format(bin_loc + "/support"))
                    elif "ENGINEER" in line:
                        uq.write('epicsEnvSet("ENGINEER", "{}")\n'.format(engineer))
                    elif "CAM-CONNECT" in line:
                        uq.write('epicsEnvSet("CAM-CONNECT", "{}")\n'.format(self.connection))
                    elif "HOSTNAME" in line:
                        uq.write('epicsEnvSet("HOSTNAME", "{}")\n'.format(hostname))
                    elif "PREFIX" in line and "CTPREFIX" not in line:
                        uq.write('epicsEnvSet("PREFIX", "{}")\n'.format(prefix + "{{{}}}".format(self.ioc_type[2:] +"-Cam:{}".format(self.ioc_num))))
                    elif "CTPREFIX" in line:
                        uq.write('epicsEnvSet("CTPREFIX", "{}")\n'.format(prefix + "{{{}}}".format(self.ioc_type[2:] +"-Cam:{}".format(self.ioc_num))))
                    elif "IOCNAME" in line:
                        uq.write('epicsEnvSet("IOCNAME", "{}")\n'.format(self.ioc_name))
                    elif "EPICS_CA_ADDR_LIST" in line:
                        uq.write('epicsEnvSet("EPICS_CA_ADDR_LIST", "{}")\n'.format(ca_ip))
                    elif "IOC" in line and "IOCNAME" not in line:
                        uq.write('epicsEnvSet("IOC", "{}")\n'.format("ioc"+self.ioc_type))
                    elif "PORT" in line:
                        uq.write('epicsEnvSet("PORT", "{}")\n'.format(self.asyn_port))
                    else:
                        uq.write(line)
                else:
                    uq.write(line)
                line = uq_old.readline()

            uq_old.close()
            uq.close()
        else:
            initIOC_print("No unique file found, proceeding to next step")


    def update_config(self, ioc_top, hostname):
        """
        Function that updates the config file with the correct IOC name, port, and hostname

        Parameters
        ----------
        ioc_top : str
            Path to the top directory to contain generated IOCs
        hostname : str
            name of the host IOC server on which the IOC will run
        """

        conf_path = ioc_top + "/" + self.ioc_name + "/config"
        if os.path.exists(conf_path):
            initIOC_print("Updating config file for procServer connection")
            conf_old_path = ioc_top + "/" + self.ioc_name + "/config_OLD"
            os.rename(conf_path, conf_old_path)
            cn_old = open(conf_old_path, "r")
            cn = open(conf_path, "w")
            line = cn_old.readline()
            while line:
                if "NAME" in line:
                    cn.write("NAME={}\n".format(self.ioc_name))
                elif "PORT" in line:
                    cn.write("PORT={}\n".format(self.ioc_port))
                elif "HOST" in line:
                    cn.write("HOST={}\n".format(hostname))
                else:
                    cn.write(line)
                line = cn_old.readline()
            cn_old.close()
            cn.close()
        else:
            initIOC_print("No config file found moving to next step")


    def fix_env_paths(self, ioc_top, bin_flat):
        """
        Function that fixes the envPaths file if binaries are not flat

        Parameters
        ----------
        ioc_top : str
            Path to the top directory to contain generated IOCs
        bin_flat : bool
            flag for deciding if binaries are flat or stacked
        """

        env_path = ioc_top + "/" + self.ioc_name + "/envPaths"
        if os.path.exists(env_path):
            env_old_path = ioc_top + "/" + self.ioc_name + "/envPaths_OLD"
            os.rename(env_path, env_old_path)
            env_old = open(env_old_path, "r")
            env = open(env_path, "w")
            line = env_old.readline()
            while line:
                if line.startswith('epicsEnvSet("ARCH",'):
                    if platform == 'win32':
                        env.write('epicsEnvSet("ARCH",       "windows-x64-static")\n')
                    else:
                        env.write('epicsEnvSet("ARCH",       "linux-x86_64")\n')
                elif "EPICS_BASE" in line and not bin_flat:
                    initIOC_print("Fixing base location in envPaths")
                    env.write('epicsEnvSet("EPICS_BASE", "$(SUPPORT)/../base")\n')
                else:
                    env.write(line)
                line = env_old.readline()
            env_old.close()
            env.close()


    def getIOCBin(self, bin_loc, bin_flat):
        """
        Function that identifies the IOC binary location based on its type and the binary structure

        Parameters
        ----------
        bin_loc : str
            path to top level of binary distribution
        bin_flat : bool
            flag for deciding if binaries are flat or stacked
        
        Return
        ------
        driver_path : str
            Path to the IOC executable located in driverName/iocs/IOC/bin/OS/driverApp or None if not found
        """

        try:
            if bin_flat:
                # if flat, there is no support directory
                driver_path = bin_loc + "/areaDetector/" + self.ioc_type
            else:
                driver_path = bin_loc + "/support/areaDetector/" + self.ioc_type
            # identify the IOCs folder
            for name in os.listdir(driver_path):
                if "ioc" == name or "iocs" == name:
                    driver_path = driver_path + "/" + name
                    break
            # identify the IOC 
            for name in os.listdir(driver_path):
                # Add check to see if NOIOC in name - occasional problems generating ADSimDetector
                if "IOC" in name or "ioc" in name and "NOIOC" not in name.upper():
                    driver_path = driver_path + "/" + name
                    break 
            # Find the bin folder
            driver_path = driver_path + "/bin"
            # There should only be one architecture
            for name in os.listdir(driver_path):
                driver_path = driver_path + "/" + name
                break
            # We look for the executable that ends with App
            for name in os.listdir(driver_path):
                if 'App' in name:
                    driver_path = driver_path + "/" + name
                    break

            return driver_path
        except FileNotFoundError:
            return None


    def fix_macros(self, file_path):
        """
        Function that replaces certain macros in given filepath (used primarily for substitution files)

        Parameters
        ----------
        file_path : str
            path to the target file
        """

        os.rename(file_path, file_path + '_OLD')
        old = open(file_path+'_OLD', 'r')
        contents = old.read()
        contents = contents.replace('$(PREFIX)', self.ioc_prefix)
        contents = contents.replace('$(PORT)', self.asyn_port)
        new = open(file_path, 'w')
        new.write(contents)
        old.close()
        new.close()
        os.remove(file_path+'_OLD')


    # TODO: need to include support/lib/arch. shouldn't include all ADDrivers, just IOC type
    def create_path_scripts(self, bin_loc, bin_flat, ioc_top):
        """
        Function that attempts to create scripts for setting the dev environment for the IOC given the location of the binaries.

        Parameters
        ----------
        bin_loc : str
            given path to binaries
        bin_flat : bool
            toggle that determines if the binaries have a flat structure or not
        ioc_top : str
            path to the ioc output_directory
        """

        if platform == "win32":
            delimeter = ';'
            closer = '%PATH%"'
            arch='windows-x64-static'
            path_file = open(ioc_top + '/' + self.ioc_name + '/dllPath.bat', 'w+')
            path_file.write('@ECHO OFF\n')
            path_file.write('SET "PATH=')
        else:
            delimeter = ':'
            closer = '$LD_LIBRARY_PATH'
            arch = 'linux-x86_64'
            path_file = open(ioc_top + '/' + self.ioc_name + '/ldpath.sh', 'w+')
            path_file.write('export LD_LIBRARY_PATH=')
        path_file.write(bin_loc + '/base/bin/' + arch)
        path_file.write(delimeter)
        path_file.write(bin_loc + '/base/lib/' + arch)
        path_file.write(delimeter)
        if bin_flat:
            support_dir = bin_loc
        else:
            support_dir = bin_loc + '/support'

        if os.path.exists(support_dir) and os.path.isdir(support_dir):
            for dir in os.listdir(support_dir):
                if os.path.isdir(support_dir + '/' + dir) and dir != "base" and dir != "areaDetector":
                    path_file.write(support_dir + '/' + dir + '/bin/' + arch)
                    path_file.write(delimeter)
                    path_file.write(support_dir + '/' + dir + '/lib/' + arch)
                    path_file.write(delimeter)

        ad_dir = support_dir + '/areaDetector'
        if os.path.exists(ad_dir) and os.path.isdir(ad_dir):
            for dir in os.listdir(ad_dir):
                if os.path.isdir(ad_dir + '/' + dir) and dir.startswith('AD'):
                    path_file.write(ad_dir + '/' + dir + '/bin/' + arch)
                    path_file.write(delimeter)
                    path_file.write(ad_dir + '/' + dir + '/lib/' + arch)
                    path_file.write(delimeter)

        path_file.write(closer)
        path_file.close()


    # TODO: change so that script is removed by initIOC instead of itself to fix error on windows
    def cleanup(self, ioc_top):
        """ Function that runs the cleanup.sh/cleanup.bat script in ioc-template to remove unwanted files """

        cleanup_completed = False

        if platform == "win32":
            if(os.path.exists(ioc_top + "/" + self.ioc_name + "/cleanup.bat")):
                initIOC_print("Performing cleanup for {}".format(self.ioc_name))
                out = subprocess.call([ioc_top + "/" + self.ioc_name + "/cleanup.bat"])
                initIOC_print('')
                cleanup_completed = True
        else:
            if(os.path.exists(ioc_top + "/" + self.ioc_name + "/cleanup.sh")):
                initIOC_print("Performing cleanup for {}".format(self.ioc_name))
                out = subprocess.call(["bash", ioc_top + "/" + self.ioc_name + "/cleanup.sh"])
                initIOC_print('')
                cleanup_completed = True
        if os.path.exists(ioc_top +"/" + self.ioc_name + "/st.cmd"):
            os.chmod(ioc_top +"/" + self.ioc_name + "/st.cmd", 0o755)
        if not cleanup_completed:
            initIOC_print("No cleanup script found, using outdated version of IOC template")


#-------------------------------------------------
#----------------MAIN SCRIPT FUNCTIONS------------
#-------------------------------------------------


def parse_line_into_action(line, prefix, ioc_num_counter):
    """
    Function that parses a line in the CONFIGURE table into an IOCAction object

    Parameters
    ----------
    line : str
        The line to parse from the table
    ioc_num_counter : int
        the ioc counter
    
    Returns
    -------
    ioc_action : IOCAction
        the IOCAction object that contains information from line or None if it cannot successfully be parsed
    """

    try:
        line = line.strip()
        line = re.sub('\t', ' ', line)
        line = re.sub(' +', ' ', line)
        temp = line.split(' ')
        ioc_action = IOCAction(temp[0], temp[1], prefix, temp[2], temp[3], temp[4], ioc_num_counter)
        return ioc_action
    except IndexError:
        initIOC_print('IOC line could not be parsed, skipping...')
        return None


def read_ioc_config():
    """
    Function for reading the CONFIGURE file. Returns a dictionary of configure options,
    a list of IOCAction instances, and a boolean representing if binaries are flat or not

    Returns
    -------
    ioc_actions : List of IOCAction
        list of IOC actions that need to be performed.
    configuration : dict of str -> str
        Dictionary containing all options read from configure
    bin_flat : bool
        toggle for flat or stacked binary directory structure
    """

    ioc_config_file = open("CONFIGURE", "r+")
    ioc_actions = []
    configuration = {}
    bin_flat = True
    ioc_num_counter = 1

    line = ioc_config_file.readline()
    while line:
        if "=" in line and not line.startswith('#') and 'BINARIES_FLAT' not in line:
            line = line.strip()
            split = line.split('=')
            configuration[split[0]] = split[1]
        elif not line.startswith('#') and len(line) > 1:
            ioc_action = parse_line_into_action(line, configuration['PREFIX'], ioc_num_counter)
            if ioc_action is not None:
                ioc_num_counter = ioc_num_counter + 1
                ioc_actions.append(ioc_action)

        line = ioc_config_file.readline()

    ioc_config_file.close()
    if os.path.exists(configuration['TOP_BINARY_DIR']):
        if os.path.exists(os.path.join(configuration['TOP_BINARY_DIR'], 'support')):
            bin_flat = False
    return ioc_actions, configuration, bin_flat


def init_ioc_dir(ioc_top):
    """
    Function that creates ioc directory if it has not already been created.

    Parameters
    ----------
    ioc_top : str
        Path to the top directory to contain generated IOCs

    Return
    ------
    bool
        True if already exists, or succesfully created, otherwise false
    """

    if ioc_top == '':
        initIOC_print('ERROR - IOC top directory not initialized')
        return False
    elif os.path.exists(ioc_top) and os.path.isdir(ioc_top):
        initIOC_print("IOC directory already exits.")
        initIOC_print('')
        return True
    else:
        try:
            os.mkdir(ioc_top)
            return True
        except PermissionError:
            initIOC_print('ERROR - Permission denied when creating IOC directory.')
            return False


def print_start_message():
    """ Function for printing initial message """

    initIOC_print("+----------------------------------------------------------------+")
    initIOC_print("+ initIOCs, Version: " + version +"                                      +")
    initIOC_print("+ Author: Jakub Wlodek                                           +")
    initIOC_print("+ Copyright (c): Brookhaven National Laboratory 2018-2019        +")
    initIOC_print("+ This software comes with NO warranty!                          +")
    initIOC_print("+----------------------------------------------------------------+")
    initIOC_print('')


def print_supported_drivers():
    """ Function that prints list of supported drivers """

    initIOC_print('Supported Drivers:')
    initIOC_print("+-----------------------------+")
    for driver in supported_drivers:
        initIOC_print('+ {}'.format(driver))
    initIOC_print('')


def execute_ioc_action(action, configuration, bin_flat):
    """
    Function that runs all required IOC action functions with a given configuration

    Parameters
    ----------
    action : IOCAction
        currently executing IOC action
    configuration : dict of str to str
        configuration settings as read from CONFIGURE or inputted by user
    bin_flat : bool
        toggle that tells the script if binaries are flat of not
    """

    # Perform the overall process action
    out = action.process(configuration["IOC_DIR"], configuration["TOP_BINARY_DIR"], bin_flat)
    # if successfull, update any remaining required files
    if out == 0:
        action.update_unique(configuration["IOC_DIR"], configuration["TOP_BINARY_DIR"], bin_flat, 
            configuration["PREFIX"], configuration["ENGINEER"], configuration["HOSTNAME"], 
            configuration["CA_ADDRESS"])
        action.update_config(configuration["IOC_DIR"], configuration["HOSTNAME"])
        action.fix_env_paths(configuration["IOC_DIR"], bin_flat)
        action.create_path_scripts(configuration["TOP_BINARY_DIR"], bin_flat, configuration["IOC_DIR"])
        action.cleanup(configuration["IOC_DIR"])


def guided_init():
    """ Function that guides the user through generating a single IOC through the CLI """

    print_start_message()
    initIOC_print('Welcome to initIOC!')
    configuration = {}
    configuration['IOC_DIR']        = input('Enter the ioc output location. > ')
    configuration['TOP_BINARY_DIR'] = input('Enter the location of your compiled binaries. > ')
    bin_flat = True
    if os.path.exists(configuration['TOP_BINARY_DIR']):
        if os.path.exists(os.path.join(configuration['TOP_BINARY_DIR'], 'support')):
            bin_flat = False
    configuration['PREFIX']     = input('Enter the IOC Prefix (without the camera specific portion ex. XF:10IDC-BI). > ')
    configuration['HOSTNAME']   = input('Enter the IOC server hostname. > ')
    configuration['ENGINEER']   = input('Enter your name and contact information. > ')
    configuration['CA_ADDRESS'] = input('Enter the CA_ADDRESS IP. > ')
    another_ioc = True
    while another_ioc:
        driver_type = None
        while driver_type is None:
            driver_type = input('What driver type would you like to generate? > ')
            if driver_type not in supported_drivers:
                driver_type = None
                initIOC_print('The selected driver type is not supported. See list of supported drivers below.')
                print_supported_drivers()
        ioc_name = input('What should the IOC name be? > ')
        asyn_port = input('What asyn port should the IOC use? (ex. PS1). > ')
        ioc_port = input('What telnet port should procServer use to run the IOC? > ')
        connection = input('Enter the connection param for your device. (ex. IP, serial number etc.) enter NA if not sure. > ')
        ioc_action = IOCAction(driver_type, ioc_name, configuration['PREFIX'], asyn_port, ioc_port, connection, 1)
        execute_ioc_action(ioc_action, configuration, bin_flat)
        another = input('Would you like to generate another IOC? (y/n). > ')
        if another != 'y':
            another_ioc = False
    initIOC_print('Done.')


def init_iocs_cli():
    """
    Main driver function. First calls read_ioc_config, then for each instance of IOCAction
    perform the process, update_unique, update_config, fix_env_paths, and cleanup functions
    """

    print_start_message()
    actions, configuration, bin_flat = read_ioc_config()
    init_iocs(actions, configuration, bin_flat)


def init_iocs(actions, configuration, bin_flat, is_gui = False):
    """
    Main driver function. Recieves actions, the configuration, and bin_flat toggle

    Parameters
    ----------
    actions : list of IOCAction
        list of iocs to generate
    configuration: dict of {str : str}
        configuration settings for current user
    bin_flat : bool
        a boolean toggle for if binary structure is flat or not.
    """

    ret = init_ioc_dir(configuration["IOC_DIR"])
    if ret:
        if len(actions) == 0:
            initIOC_print('No IOCs detected in table.')
        for action in actions:
            if action.ioc_type not in supported_drivers:
                initIOC_print('ERROR - {} is not currently a supported driver!'.format(action.ioc_type))
                print_supported_drivers()
                initIOC_print('To request support for {} to be added to initIOC, please create an issue on:'.format(action.ioc_type))
                initIOC_print('https://github.com/epicsNSLS2-deploy/initIOC/issues')
            else:
                execute_ioc_action(action, configuration, bin_flat)


def initIOC_print(text):
    """
    A wrapper function for 'print' that allows for printing to CLI or to log
    """

    if USING_GUI and GUI_TOP_WINDOW is not None:
        GUI_TOP_WINDOW.writeToLog(text + '\n')
    else:
        print(text)


#-------------------------------------------------
#---------------- MAIN GUI CLASSES ---------------
#-------------------------------------------------


class ToolTip(object):
    """
    Class for handling tool tips in the initIOC GUI.

    Attributes
    ----------
    widget : tkinter widget
        target widget for which to display tooltip
    tipwindow : window
        tooltip window
    id : int
        id number
    x, y : int
        coordinates of the tooltip
    """

    # Written by Michael Posada

    def __init__(self, widget):
        """ Constructor for ToolTip class """

        self.widget = widget
        self.tipwindow = None
        self.id = None
        self.x = 0
        self.y = 0

    def showtip(self, text):
        """ Function that actually displays the tooltip """

        self.text = text
        if self.tipwindow or not self.text:
            return
        x, y, cx, cy = self.widget.bbox("insert")
        x = x + self.widget.winfo_rootx() + 57
        y = y + cy + self.widget.winfo_rooty() +27
        self.tipwindow = tw = Toplevel(self.widget)
        tw.wm_overrideredirect(1)
        tw.wm_geometry("+%d+%d" % (x, y))
        label = Label(tw, text=self.text, justify=LEFT,
                      background="#ffffe0", relief=SOLID, borderwidth=1,
                      font=("tahoma", "8", "normal"))
        label.pack(ipadx=1)

    def hidetip(self):
        """ Function that destroys the tooltip """

        tw = self.tipwindow
        self.tipwindow = None
        if tw:
            tw.destroy()


def CreateToolTip(widget, text):
    """
    Function that binds the tooltip to a widget

    Parameters
    ----------
    widget : tkinter widget
        widget to bind to
    text : str
        tooltip text
    """

    toolTip = ToolTip(widget)
    def enter(event):
        toolTip.showtip(text)
    def leave(event):
        toolTip.hidetip()
    widget.bind('<Enter>', enter)
    widget.bind('<Leave>', leave)


class InitIOCGui:
    """
    Class representing the main GUI for initIOCs.

    Attributes
    ----------
    master : Tk window
        the containing window
    frame : tk frame
        the main frame
    ioc_num_counter : int
        counter for number of IOCs deployed.
    actions, configuration, bin_flat : list of IOCAction, dict of {str,str}, bool
        configuration of IOCs to generate

    Methods
    -------
    initWindow()
        initializes the window
    writeToIOCPanel()
        writes to the ioc panel
    readGUIConfig()
        parses gui data into actions, configuration, binflat
    execute()
        executes the ioc actions
    save()
        saves the IOC configuration
    openAddIOCWindow()
        opens window to add new IOC
    """

    def __init__(self, master):     
        """ Constructor for InitIOCGui """

        self.master = master


        self.master.protocol('WM_DELETE_WINDOW', self.thread_cleanup)
        self.frame = Frame(self.master)
        self.frame.pack()

        self.largeFont = tkFont.Font(size = 12)
        self.largeFontU = tkFont.Font(size = 12)
        self.largeFontU.configure(underline = True)

        self.showPopups = BooleanVar()
        self.showPopups.set(True)
        self.askAnother = BooleanVar()
        self.askAnother.set(False)

        self.ioc_num_counter = 1
        self.executionThread = threading.Thread()

        menubar = Menu(self.master)

        filemenu = Menu(menubar, tearoff=0)
        filemenu.add_command(label='Save Configuration',    command=self.save)
        filemenu.add_command(label='Save Log',              command=self.saveLog)
        filemenu.add_command(label='Clear Log',             command=self.clearLog)
        filemenu.add_command(label='Exit',                  command=self.thread_cleanup)
        menubar.add_cascade(label='File', menu=filemenu)

        editmenu = Menu(menubar, tearoff=0)
        editmenu.add_command(label='Add IOC', command=self.openAddIOCWindow)
        editmenu.add_command(label='Clear IOC table', command=self.initIOCPanel)
        editmenu.add_checkbutton(label='Toggle Popups', onvalue=True, offvalue=False, variable=self.showPopups)
        editmenu.add_checkbutton(label='Ask to Add Multiple IOCs', onvalue=True, offvalue=False, variable=self.askAnother)
        menubar.add_cascade(label='Edit', menu=editmenu)

        runmenu = Menu(menubar, tearoff=0)
        runmenu.add_command(label='Generate IOCs', command=self.execute)
        menubar.add_cascade(label='Run', menu=runmenu)

        helpmenu = Menu(menubar, tearoff=0)
        helpmenu.add_command(label='Online Docs', command=lambda: webbrowser.open('https://epicsnsls2-deploy.github.io/Deploy-Docs/#initIOC-step-by-step-example', new=2))
        helpmenu.add_command(label='initIOC on Github', command = lambda: webbrowser.open('https://github.com/epicsNSLS2-deploy/initIOC', new=2))
        helpmenu.add_command(label='Report an Issue', command = lambda: webbrowser.open('https://github.com/epicsNSLS2-deploy/initIOC/issues', new=2))
        helpmenu.add_command(label='Supported Drivers', command=print_supported_drivers)
        helpmenu.add_command(label = 'About', command=print_start_message)
        menubar.add_cascade(label='Help', menu=helpmenu)

        self.master.config(menu=menubar)

        # Read initial configuration from save file
        self.actions, self.configuration, self.bin_flat = read_ioc_config()

        # User inputs for all configuration options
        self.text_inputs = {}
        row_counter = 0

        for elem in self.configuration.keys():
            self.text_inputs[elem] = StringVar()
            elem_label=Label(self.frame, text=elem).grid(row=row_counter, column=0, padx = 10, pady = 10)
            elem_entry = Entry(self.frame, textvariable=self.text_inputs[elem], width=30)
            elem_entry.grid(row=row_counter, column=1, columnspan = 2, padx=10, pady=10)
            elem_entry.insert(0, self.configuration[elem])
            CreateToolTip(elem_entry, config_tooltips[elem])
            row_counter = row_counter + 1
        
        self.master.title('initIOC GUI')

        ttk.Separator(self.frame, orient=HORIZONTAL).grid(row=row_counter, columnspan=3, padx = 5, sticky = 'ew')

        Label(self.frame, text='IOC Generation Table - You may edit this table manually, or add new IOCs with the Add Button').grid(row = 0, column = 3, columnspan = 5, padx = 10, pady = 10)
        self.iocPanel = ScrolledText.ScrolledText(self.frame, width = '75', height = '15')
        self.iocPanel.grid(row = 1, column = 3, padx = 15, pady = 15, columnspan = 5, rowspan = row_counter + 1)
        self.initIOCPanel()
        for action in self.actions:
            self.writeToIOCPanel(action.ioc_type, action.ioc_name, action.asyn_port, action.ioc_port, action.connection)

        Label(self.frame, text='Log', font=self.largeFontU).grid(row = row_counter + 1, column = 0, padx = 5, pady = 0)
        self.logPanel = ScrolledText.ScrolledText(self.frame, width='100', height = '15')
        self.logPanel.grid(row = row_counter + 2, column = 0, rowspan = 5, columnspan = 4, padx = 10, pady = 10)

        saveButton  = Button(self.frame, text="Save",     font=self.largeFont, command=self.save,                height='3', width='20')
        runButton   = Button(self.frame, text="Run",      font=self.largeFont, command=self.execute,             height='3', width='20')
        addButton   = Button(self.frame, text="Add IOC",  font=self.largeFont, command=self.openAddIOCWindow,    height='3', width='20')
        saveButton.grid(row=row_counter+3, column=5, columnspan=2, padx=5, pady=5)
        runButton.grid( row=row_counter+4, column=5, columnspan=2, padx=5, pady=5)
        addButton.grid( row=row_counter+5, column=5, columnspan=2, padx=5, pady=5)


    def initIOCPanel(self):
        """ Function that resets the IOC panel """

        self.iocPanel.delete('1.0', END)
        self.iocPanel.insert(INSERT, '# IOC Type        IOC Name     Asyn Port      IOC Port      Cam Connection\n')
        self.iocPanel.insert(INSERT, '#-------------------------------------------------------------------------\n')


    def writeToIOCPanel(self, ioc_type, name, asyn, port, connect):
        """ Function that writes to the iocPanel """

        self.iocPanel.insert(INSERT, '{:<18}{:<15}{:<15}{:<12}{}\n'.format(ioc_type, name, asyn, port, connect))


    def writeToLog(self, text):
        """ Function that writes text to the GUI log """

        self.logPanel.insert(INSERT, text)
        self.logPanel.see(END)


    def showError(self, text):

        if self.showPopups.get():
            messagebox.showerror('ERROR', text)
        self.writeToLog('ERROR - ' + text + '\n')


    def showWarning(self, text):

        if self.showPopups.get():
            messagebox.showerror('WARNING', text)
        self.writeToLog('WARNING - ' + text + '\n')


    def showMessage(self, text):

        if self.showPopups.get():
            messagebox.showerror('Info', text)
        self.writeToLog(text + '\n')


    def read_gui_config(self):
        """ Function that reads values entered into gui into actions, configuration, and bin_flat """

        for elem in self.text_inputs.keys():
            if self.text_inputs[elem].get() != self.configuration[elem]:
                self.configuration[elem] = self.text_inputs[elem].get()

        self.bin_flat = True
        if os.path.exists(self.configuration['TOP_BINARY_DIR']):
            if os.path.exists(os.path.join(self.configuration['TOP_BINARY_DIR'], 'support')):
                self.bin_flat = False

        self.actions.clear()
        for line in self.iocPanel.get('1.0', END).splitlines():
            if not line.startswith('#') and len(line) > 1:
                action = parse_line_into_action(line, self.configuration['PREFIX'], self.ioc_num_counter)
                if action is not None:
                    self.actions.append(action)
                    self.ioc_num_counter = self.ioc_num_counter + 1
                else:
                    self.showWarning('Could not parse one of the IOC lines entered into the table.')


    def execute(self):
        """ Reads gui info, and runs init_iocs """

        if self.executionThread.is_alive():
            self.showError('Process thread is already active!')
        else:
           self.read_gui_config()
           self.executionThread = threading.Thread(target=lambda: init_iocs(self.actions, self.configuration, self.bin_flat))
           self.executionThread.start()


    def save(self):
        """ Saves the current IOC configuration """

        self.read_gui_config()
        if os.path.exists('CONFIGURE'):
            os.remove('CONFIGURE')
        file = open('CONFIGURE', 'w')
        file.write('#\n# initIOCs CONFIGURE file autogenerated on {}\n#\n\n'.format(datetime.datetime.now()))
        for elem in self.configuration.keys():
            file.write('# {}\n'.format(config_tooltips[elem]))
            file.write('{}={}\n\n'.format(elem, self.configuration[elem]))

        file.write(self.iocPanel.get('1.0', END))
        self.showInfo('Saved configuration to CONFIGURE file.')


    def saveLog(self):
        """ Function that saves the current log into a log file """

        if not os.path.exists('logs'):
            os.mkdir('logs')
        elif not os.path.isdir('logs'):
            self.showError('logs directory could not be created, logs file exists')
        log = open('logs/initIOC-{}.log'.format(datetime.datetime.now()), 'w')
        log.write(self.logPanel.get('1.0', END))
        log.close()
        self.writeToLog('Wrote log file.\n')


    def clearLog(self):
        """ Reinitializes the log """

        self.logPanel.delete('1.0', END)
        print_start_message()


    def openAddIOCWindow(self):
        """ Opens an addIOC window """

        AddIOCWindow(self)


    def thread_cleanup(self):
        if self.executionThread.is_alive():
            self.executionThread.join()
        self.master.destroy()


class AddIOCWindow:
    """
    Class representing a window for adding a new IOC into the config
    """

    def __init__(self, root):

        self.root = root
        self.master = Toplevel()
        self.master.title('Add New IOC')
        
        # Create the entry fields for all the paramters
        self.ioc_type_var       = StringVar()
        self.ioc_name_var       = StringVar()
        self.asyn_port_var      = StringVar()
        self.ioc_port_var       = StringVar()
        self.cam_connect_var    = StringVar()  

        ioc_type_label      = Label(self.master, text="IOC Type").grid(row = 0, column = 0, padx = 10, pady = 10)
        ioc_type_entry      = Entry(self.master, textvariable=self.ioc_type_var)
        ioc_type_entry.grid(row = 0, column = 1, columnspan=2, padx = 10, pady = 10)
        CreateToolTip(ioc_type_entry, 'The IOC type. Must be from list of supported drivers.')

        ioc_name_label      = Label(self.master, text="IOC Name").grid(row = 1, column = 0, padx = 10, pady = 10)
        ioc_name_entry      = Entry(self.master, textvariable=self.ioc_name_var)
        ioc_name_entry.grid(row = 1, column = 1, columnspan=2, padx = 10, pady = 10)
        CreateToolTip(ioc_name_entry, 'The name of the IOC. Usually cam-$NAME')

        asyn_port_label     = Label(self.master, text="Asyn Port").grid(row = 2, column = 0, padx = 10, pady = 10)
        asyn_port_entry     = Entry(self.master, textvariable=self.asyn_port_var)
        asyn_port_entry.grid(row = 2, column = 1, columnspan=2, padx = 10, pady = 10)
        CreateToolTip(asyn_port_entry, 'IOC Asyn port. Usually Shorthand of IOC type and number. ex. SIM1')

        ioc_port_label      = Label(self.master, text="IOC Port").grid(row = 3, column = 0, padx = 10, pady = 10)
        ioc_port_entry      = Entry(self.master, textvariable=self.ioc_port_var)
        ioc_port_entry.grid(row = 3, column = 1, columnspan=2, padx = 10, pady = 10)
        CreateToolTip(ioc_port_entry, 'Telnet port used by softioc when running the IOC')

        cam_connect_label   = Label(self.master, text="Cam Connection").grid(row = 4, column = 0, padx = 10, pady = 10)
        cam_connect_entry   = Entry(self.master, textvariable=self.cam_connect_var)
        cam_connect_entry.grid(row = 4, column = 1, columnspan=2, padx = 10, pady = 10)
        CreateToolTip(cam_connect_entry, 'A general parameter used to connect to camera. Typically IP, Serial #, config path, etc.')

        Button(self.master,text="Submit", command=self.submit).grid(row = 5, column = 0, padx = 10, pady = 10)
        Button(self.master,text="Cancel", command=self.master.destroy).grid(row = 5, column = 2, padx = 10, pady = 10)


    def submit(self):
        """ Function that enters the filled IOC values into the configuration """

        if self.ioc_type_var.get() not in supported_drivers:
            self.root.showError('The selected IOC type is not supported.')
            self.master.destroy()
            return

        ioc_type = self.ioc_type_var.get()
        name = self.ioc_name_var.get()
        asyn = self.asyn_port_var.get()
        port = self.ioc_port_var.get()
        connect = self.cam_connect_var.get()
        if ioc_type == '' or name == '' or asyn == '' or port == '' or connect == '':
            self.root.showError('Please enter a valid value for all of the fields.')
            return

        self.root.writeToIOCPanel(ioc_type, name, asyn, port, connect)
        self.root.writeToLog('Added IOC {} to configuration.\n'.format(name))

        if self.root.askAnother.get():
            res = messagebox.askyesno('Continue', 'Would you like to add another IOC?')
            if res is not None and not res:
                self.master.destroy()
            elif res is not None:
                self.ioc_name_var.set('')
                self.ioc_type_var.set('')
                self.ioc_port_var.set('')
                self.asyn_port_var.set('')
                self.cam_connect_var.set('')
        else:
            self.master.destroy()




def parse_args():
    """ Main driver function that parses the command line arguments """

    global GUI_TOP_WINDOW
    global USING_GUI

    parser = argparse.ArgumentParser(description='A script for auto-initializing areaDetector IOCs. Edit the CONFIGURE file and run without arguments for default operation.')

    parser.add_argument('-i', '--individual',   action='store_true', help='Add this flag to go through a guided process for generating a single IOC at a time.')
    parser.add_argument('-g', '--gui',          action='store_true', help='Add this flag to enable the GUI version of initIOC.')
    arguments = vars(parser.parse_args())
    if arguments['individual']:
        # If user selects a guided init, perform that
        guided_init()
    elif arguments['gui']:
        # otherwise if user selects GUI, open it provided all required imports went through
        if not WITH_GUI:
            print('ERROR - tkinter not found for your python3 distribution, required for GUI.')
            print('Please either install tkinter or use the command line option for initIOC.')
            print('Exiting...')
            exit()
        else:
            root = Tk()

            USING_GUI = True
            app = InitIOCGui(root)
            
            GUI_TOP_WINDOW = app
            print_start_message()
            root.mainloop()

    else:
        # Otherwise perform default initIOCs through the CLI
        init_iocs_cli()


# Run the script
parse_args()



