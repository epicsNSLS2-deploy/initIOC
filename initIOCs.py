#!/usr/bin/env python3

"""Script for auto initialization of IOCs from CONFIGURE file.

This script was taken from the installSynApps set of scripts.
Usage instructions can be found in the README.md file in this repo.

Author: Jakub Wlodek
"""

# imports
import os
import re
import time
import shutil
import subprocess
import argparse
import datetime
import sys
from sys import platform


# variables used to allow for printing text to GUI or stdout depending on usage
USING_GUI=False
GUI_TOP_WINDOW=None

# version number
__version__ = "v0.1.0"


#-------------------------------------------------
#-------- CONSTANTS AND REQ. DATA STRUCTS --------
#-------------------------------------------------

# Bash shebang length limit is 127 characters, so we need to make sure we account for that
KERNEL_PATH_LIMIT = 127


# list of currently supported drivers (for template based generation). Also used for dropdown in GUI
supported_drivers = [
    'ADProsilica',
    'ADUVC',
    'ADPointGrey',
    'ADLambda',
    'ADSimDetector',
    'ADMerlin',
    'ADPerkinElmer',
    'ADPilatus',
    'ADSpinnaker',
    'ADAndor3',
    'ADURL',
    'ADPSL',
    'ADEiger',
]


# Tooltip messages for the configuration options
config_tooltips = {
    'IOC_DIR' :         'Top level IOC output directory',
    'TOP_BINARY_DIR' :  'Location of compiled binaries on your system.',
    'PREFIX' :          'Generic prefix added to start of each IOC PV name. Unique portion will be autogenerated',
    'ENGINEER' :        'Engineer deploying the IOCs',
    'HOSTNAME' :        'Hostname of IOC server on which it will be deployed',
    'CA_ADDRESS' :      'Channel access address list IP'
}


# Some default values for generating a temporary CONFIGURE file.
base_configuration = {
    'IOC_DIR' :         '/epics/iocs',
    'TOP_BINARY_DIR' :  '/epics/src',
    'PREFIX' :          'DEVEL1:',
    'ENGINEER' :        'C. Engineer',
    'HOSTNAME' :        'localhost',
    'CA_ADDRESS' :      '127.0.0.255'
}


# Certain drivers already include an existing connection parameter environment variable.
# This is no longer required, since CAM-CONNECT is used instead.
existing_connection_parameter = {
    "ADEiger"       : "EIGER_IP",
    "ADAravis"      : "CAMERA_NAME",
    "ADVimba"       : "CAMERA_ID",
    "ADSpinnaker"   : "CAMERA_ID",
    "ADUVC"         : "UVC_SERIAL"
}


# List of drivers that don't have connection parameters
no_connection_param_drivers = ['ADSimDetector']


# On windows default to C directory
if platform == 'win32':
    base_configuration['IOC_DIR'] = 'C:' + base_configuration['IOC_DIR']
    base_configuration['TOP_BINARY_DIR'] = 'C:' + base_configuration['TOP_BINARY_DIR']


# External areaDetector plugins
ad_plugins = ['ADCompVision', 'ADPluginBar', 'ADPluginEdge', 'ADPluginDmtx']

#-------------------------------------------------
#------------ INTERNAL DATA MODEL CLASS ----------
#-------------------------------------------------


def initIOC_path_join(path_A, path_B):
    """Function that joins two paths.

    All paths use / instead of \\ for simplicity.
    """

    output_path = path_A
    if not path_A.endswith('/'):
        output_path = output_path + '/'
    if path_B.startswith('/'):
        output_path = output_path + path_B[1:]
    else:
        output_path = output_path + path_B

    if output_path.endswith('/'):
        output_path = output_path[:-1]

    return output_path


class IOCActionManager:

    def __init__(self, ioc_top, binary_location, set_lib_path, use_template, with_deps, use_links):

        self.ioc_top            = ioc_top
        self.ioc_top_created    = False
        self.binary_location    = binary_location
        self.binaries_flat      = self.check_binaries_flat()
        self.set_lib_path       = set_lib_path
        self.use_template       = use_template
        self.with_deps          = with_deps
        self.use_links          = use_links
        self.processed_actions  = []
        self.update_mod_paths()


    def check_binaries_flat(self):
        if os.path.exists(initIOC_path_join(self.binary_location, 'support')):
            return False
        return True


    def deployment_info(self, action):
        """Function that generates string of info for current IOCAction
        """

        info = ''
        info = info + '#\n# {} IOC deployed using initIOC {}\n'.format(action.ioc_type, __version__)
        info = info + '# Initial target bundle location: {}\n'.format(self.binary_location)
        if self.use_template:
            info = info + '# IOC generated from: https://github.com/epicsNSLS2-deploy/ioc-template\n'
        else:
            _, _, iocBoot_path = self.find_paths_for_action(action)
            if iocBoot_path is not None:
                info = info + '# IOC generated from: {}\n'.format(iocBoot_path)

        info = info + '#{}\n'.format('-' * 64)
        return info


    def update_mod_paths(self):
        """Function that sets the paths of core modules based on binary location and format
        """

        self.binaries_flat = self.check_binaries_flat()
        self.base_path = initIOC_path_join(self.binary_location, 'base')
        if self.binaries_flat:
            self.support_path = self.binary_location
        else:
            self.support_path = initIOC_path_join(self.binary_location, 'support')

        self.areaDetector_path = initIOC_path_join(self.support_path, 'areaDetector')


    def find_paths_for_action(self, action):
        """Finds ioc_top, executable, and iocBoot folder for IOCAction
        """

        try:
            driver_path = initIOC_path_join(self.areaDetector_path, action.ioc_type)

            # identify the IOCs folder
            for name in os.listdir(driver_path):
                if "ioc" == name or "iocs" == name:
                    driver_path = initIOC_path_join(driver_path, name)
                    break

            # identify the IOC 
            for name in os.listdir(driver_path):
                # Add check to see if NOIOC in name - occasional problems generating ADSimDetector
                if ("IOC" in name or "ioc" in name) and "NOIOC" not in name.upper():
                    driver_path = initIOC_path_join(driver_path, name)
                    break

            ioc_top_path = driver_path

            # find the driver executable
            executable_path = initIOC_path_join(driver_path, "bin")
            # There should only be one architecture
            for name in os.listdir(executable_path):
                executable_path = initIOC_path_join(executable_path, name)
                break

            # We look for the executable that ends with App
            for name in os.listdir(executable_path):
                if 'App' in name:
                    executable_path = initIOC_path_join(executable_path, name)
                    break

            iocBoot_path = initIOC_path_join(driver_path, 'iocBoot')
            for dir in os.listdir(iocBoot_path):
                if dir.startswith('ioc') and dir.lower().endswith(action.basename):
                    iocBoot_path = initIOC_path_join(iocBoot_path, dir)
                    break
            return os.path.abspath(ioc_top_path), os.path.abspath(executable_path), os.path.abspath(iocBoot_path)
        except:
            return None, None, None


    def get_lib_path_for_module(self, module_path, architecture, delimeter):
        """Generates a library path for specific module
        """

        bin_loc = initIOC_path_join(module_path, 'bin')
        bin_loc = initIOC_path_join(bin_loc, architecture)
        lib_loc = initIOC_path_join(module_path, 'lib')
        lib_loc = initIOC_path_join(lib_loc, architecture)
        return bin_loc + delimeter + lib_loc + delimeter


    def get_lib_path_str(self, action):
        """Function that generates library path for shared built iocs

        Parameters
        ----------
        action : IOCAction
            ioc action for which we are generating lib path.

        Returns
        -------
        lib_path : str
            Library path set in form of str
        """

        lib_path_str = ''
        if platform == "win32":
            delimeter = ';'
            closer = '%PATH%"'
            arch='windows-x64-static'
            
        else:
            arch = 'linux-x86_64'
            delimeter = ':'
            closer = '$LD_LIBRARY_PATH'

        if platform == "win32":
            lib_path_str = lib_path_str + 'SET "PATH='
        else:
            lib_path_str = lib_path_str + 'export LD_LIBRARY_PATH='

        lib_path_str = lib_path_str + self.get_lib_path_for_module(self.base_path, arch, delimeter)

        if os.path.exists(self.support_path) and os.path.isdir(self.support_path):
            for dir in os.listdir(self.support_path):
                mod_path = initIOC_path_join(self.support_path, dir)
                if os.path.isdir(mod_path) and dir != "base" and dir != "areaDetector":
                    lib_path_str = lib_path_str + self.get_lib_path_for_module(mod_path, arch, delimeter)

        if os.path.exists(self.areaDetector_path) and os.path.isdir(self.areaDetector_path):
            for dir in os.listdir(self.areaDetector_path):
                mod_path = initIOC_path_join(self.areaDetector_path, dir)
                if os.path.isdir(mod_path) and (dir == 'ADCore' or dir == 'ADSupport' or dir in ad_plugins or dir == action.ioc_type):
                    lib_path_str = lib_path_str + self.get_lib_path_for_module(mod_path, arch, delimeter)

        lib_path_str = lib_path_str + closer
        return lib_path_str
    

    def initialize_ioc_directory(self):
        """Function used to create a new IOC directory if it does not already exist
        """

        if not os.path.exists(os.path.dirname(self.ioc_top)):
            initIOC_print('ERROR - IOC top directory {} could not be created'.format(self.ioc_top))
        else:
            if os.path.exists(self.ioc_top):
                initIOC_print('IOC top directory already exists.\n')
            else:
                try:
                    initIOC_print('Creating IOC directory at {}.\n'.format(self.ioc_top))
                    os.mkdir(self.ioc_top)
                except PermissionError:
                    initIOC_print('ERROR - You do not have permissions to write to specified directory!')
                    return False
            self.ioc_top_created = True

        return True


    def initialize_st_base_file(self, ioc_path, lib_path, executable_path):
        """Function responsible for handling executable path injection, and base file creation
        """

        exec_written    = False
        if platform == 'win32':
            # On windows, no shebangs, so st.cmd will always run executable followed by st_base.cmd
            st_exe = open(initIOC_path_join(ioc_path, 'st.cmd'), 'w+')
            st_exe.write('@echo OFF\n\n{}\n\n{} st_base.cmd\n'.format(lib_path, executable_path))
            st_exe.close()
            st = open(initIOC_path_join(ioc_path, "st_base.cmd"), "w+")
            exec_written = True

        elif len(executable_path) > KERNEL_PATH_LIMIT or self.set_lib_path:
            if len(executable_path) > KERNEL_PATH_LIMIT:
                # The path length limit for shebangs (#!/) on linux is usually kernel based and set to 127
                initIOC_print('WARNING - Path to executable exceeds legal bash shebang limit, splitting into st.cmd and st_base.cmd')
            else:
                # If we want to set LD_LIBRARY_PATH we do that here.
                initIOC_print('Appending library path to start of st.cmd...')
            st_exe = open(initIOC_path_join(ioc_path, 'st.cmd'), 'w+')
            st_exe.write('#!/bin/bash\n\n{}\n\n{} st_base.cmd\n'.format(lib_path, executable_path))
            st_exe.close()
            st = open(initIOC_path_join(ioc_path, "st_base.cmd"), "w+")
            exec_written = True
        else:
            st = open(initIOC_path_join(ioc_path, "st.cmd"), "w+")

        return st, exec_written


    def genertate_st_cmd(self, action, executable_path, st_base_path):

        initIOC_print('Generating st.cmd using base file:\n{}'.format(st_base_path))
        ioc_path        = initIOC_path_join(self.ioc_top, action.ioc_name)

        lib_path        = ''
        if self.set_lib_path:
            lib_path  = self.get_lib_path_str(action)
        
        # Create base st.cmd, add call to executable
        st, exec_written = self.initialize_st_base_file(ioc_path, lib_path, executable_path)

        # If the executable will be in the base file, write the shebang
        if not exec_written:
            st.write('#!{}\n\n'.format(executable_path))

        # Define envPaths
        st.write('< envPaths\n\n')

        # Open existing st.cmd base file
        st_base_fp = open(st_base_path, 'r')

        # Read through the lines, add a 'unique.cmd' call after all env sets, and add envSet calls to action environment
        lines = st_base_fp.readlines()
        wrote_unique = False
        for line in lines:
            if line.startswith('#!') or 'unique.cmd' in line or 'envPaths' in line:
                pass
            elif line.startswith('#'):
                st.write(line)
            elif 'Config(' in line and not wrote_unique:
                st.write('\n< unique.cmd\n\n')
                st.write(line)
                wrote_unique = True
            elif line.startswith('epicsEnvSet'):
                action.add_to_environment(line)
                st.write(line)
            else:
                st.write(line)

        st_base_fp.close()
        st.close()

        # Collect environment variables set in any other files
        self.grab_additional_env(action, st_base_path)
        # Make st.cmd executable.
        os.chmod(initIOC_path_join(ioc_path, "st.cmd"), 0o755)

    
    def grab_additional_env(self, action, st_base_path):
        """Function that collects any additional environment variables for IOC
        """

        iocBoot_dir = os.path.dirname(st_base_path)
        st_file = os.path.basename(st_base_path)

        for file in os.listdir(iocBoot_dir):
            # For any file that isnt the base file, add environment variables.
            if file.startswith('st') and file.endswith('.cmd') and file != st_file:
                fp = open(os.path.join(iocBoot_dir, file), 'r')
                lines = fp.readlines()
                for line in lines:
                    if line.startswith('epicsEnvSet'):
                        action.add_to_environment(line)
                fp.close()


    def generate_unique_cmd(self, action):

        initIOC_print('Generating unique.cmd from detected environment...')
        ioc_path = initIOC_path_join(self.ioc_top, action.ioc_name)
        unique_fp = open(initIOC_path_join(ioc_path, 'unique.cmd'), 'w')

        unique_fp.write('#############################################\n')
        unique_fp.write('# initIOC Auto-Generated Unique File        #\n')
        unique_fp.write('# Generated: {:<31}#\n'.format(str(datetime.datetime.now())))
        if 'ENGINEER' in action.epics_environment.keys():
            unique_fp.write('# Deploying Engineer: {:<22}#\n'.format(action.epics_environment['ENGINEER']))
        unique_fp.write('#############################################\n\n\n')

        unique_fp.write(self.deployment_info(action)+'\n\n')

        for env_var in action.epics_environment.keys():
            if env_var in existing_connection_parameter.keys():
                unique_fp.write('epicsEnvSet("{}",{}"{}"'.format(env_var, ' ' * (32 - len(env_var)), action.connection))
            else:
                unique_fp.write('epicsEnvSet("{}",{}"{}")\n'.format(env_var, ' ' * (32 - len(env_var)), action.epics_environment[env_var]))

        unique_fp.close()


    def get_env_paths_name(self, module):

        if module == 'seq':
            return 'SNCSEQ'
        elif module == 'iocStats':
            return 'DEVIOCSTATS'
        elif module == 'areaDetector':
            return 'AREA_DETECTOR'
        else:
            return module.upper()


    def generate_env_paths(self, ioc_top_path, ioc_boot_path, target, action):

        if not self.use_links:

            initIOC_print('Generating envPaths based on discovered compiled binaries...')
            ioc_path = initIOC_path_join(self.ioc_top, action.ioc_name)
            envPaths_fp = open(initIOC_path_join(ioc_path, 'envPaths'), 'w')

            arch='linux-x86_64'
            if platform == 'win32':
                arch = 'windows-x64-static'

            envPaths_fp.write('# Path propagated to remaining envPaths (binary bundle location)\nepicsEnvSet("BINARY_TOP", "{}")\n\n'.format(self.binary_location))
            envPaths_fp.write('epicsEnvSet("ARCH", "{}")\n'.format(arch))
            envPaths_fp.write('epicsEnvSet("TOP", "{}")\n'.format(ioc_top_path))

            base_path = initIOC_path_join('$(BINARY_TOP)', 'base')
            envPaths_fp.write('epicsEnvSet("EPICS_BASE",{}"{}")\n'.format((' ' * 14), base_path))

            support_path = "$(BINARY_TOP)"
            if not self.binaries_flat:
                support_path = initIOC_path_join(support_path, "support")

            envPaths_fp.write('epicsEnvSet("SUPPORT",{}"{}")\n\n'.format((' ' * 17), support_path))

            for dir in os.listdir(self.support_path):
                mod_path = initIOC_path_join(self.support_path, dir)
                if os.path.isdir(mod_path) and dir not in ['base', 'configure', 'utils', 'documentation', '.git', 'lib', 'bin']:
                    mod_path = initIOC_path_join('$(SUPPORT)', dir)
                    envPaths_fp.write('epicsEnvSet("{}",{}"{}")\n'.format(self.get_env_paths_name(dir), ' ' * (24 - len(self.get_env_paths_name(dir))), mod_path))

            envPaths_fp.write('\n')

            for dir in os.listdir(self.areaDetector_path):
                mod_path = initIOC_path_join(self.areaDetector_path, dir)
                if os.path.isdir(mod_path) and dir not in ['configure', 'docs', 'documentation', 'ci', '.git', '']:
                    mod_path = initIOC_path_join('$(AREA_DETECTOR)', dir)
                    envPaths_fp.write('epicsEnvSet("{}",{}"{}")\n'.format(self.get_env_paths_name(dir), ' ' * (24 - len(self.get_env_paths_name(dir))), mod_path))

            envPaths_fp.close()
        
        else:
            os.symlink(initIOC_path_join(ioc_boot_path, 'envPaths'), initIOC_path_join(target, 'envPaths'))


    def process_action(self, action):

        if not self.ioc_top_created:
            ret = self.initialize_ioc_directory()
            if not ret:
                return

        initIOC_print("-------------------------------------------")
        initIOC_print("Setup process for IOC " + action.ioc_name)
        initIOC_print("-------------------------------------------")

        from_template = self.use_template
        ioc_top_path, executable_path, iocBoot_path = self.find_paths_for_action(action)
        
        if executable_path is None:
            initIOC_print('ERROR - Could not find binary for {}, skipping...'.format(action.ioc_type))
            initIOC_print('Make sure binary for {} exists at binary path:\n{}'.format(action.ioc_type, self.binary_location))
            return
        elif ioc_top_path is None or iocBoot_path is None:
            if not from_template:
                initIOC_print('WARNING - Could not find ioc top and iocBoot folder, defaulting to use template.')
            from_template = True
        
        if os.path.exists(initIOC_path_join(self.ioc_top, action.ioc_name)):
            initIOC_print('ERROR - IOC with name {} already exists in {}.'.format(action.ioc_name, self.ioc_top))
            return

        if not from_template:
            self.create_ioc_from_bundle(action, ioc_top_path, executable_path, iocBoot_path)
        else:
            self.create_ioc_from_template(action, executable_path)

        self.create_config_file(action)
        #self.make_ignore_files(action) TODO
        initIOC_print('Done.\n')


    def create_config_file(self, action):

        initIOC_print('Generating config file for use with procServ...')
        ioc_path = initIOC_path_join(self.ioc_top, action.ioc_name)
        config_fp = open(initIOC_path_join(ioc_path, 'config'), 'w')
        config_fp.write('NAME={}\nPORT={}\nUSER=softioc\nHOST={}\n'.format(action.ioc_name, action.ioc_port, action.epics_environment['HOSTNAME']))
        config_fp.close()


    def create_ioc_from_bundle(self, action, ioc_top_path, executable_path, iocBoot_path):

        initIOC_print('Generating IOC from detected bundle located at: {}'.format(self.binary_location))
        time.sleep(0.3)
        ioc_path = initIOC_path_join(self.ioc_top, action.ioc_name)
        os.mkdir(ioc_path)
        os.mkdir(initIOC_path_join(ioc_path, 'autosave'))

        current_base_len = 0
        current_base = None
        for file in os.listdir(iocBoot_path):
            next = initIOC_path_join(iocBoot_path, file)
            if os.path.isfile(next) and file.startswith('st'):
                fp = open(next, 'r')
                lines = fp.readlines()
                fp.close()
                if len(lines) > current_base_len:
                    current_base = next
                    current_base_len = len(lines)

        if current_base is None:
            initIOC_print('ERROR - Could not fine suitable st_base file. Aborting...')
            return

        self.genertate_st_cmd(action, executable_path, current_base)
        self.generate_unique_cmd(action)
        self.generate_env_paths(ioc_top_path, iocBoot_path, ioc_path, action)
        self.grab_dependencies_from_bundle(ioc_path, iocBoot_path)

    
    def grab_dependencies_from_bundle(self, ioc_path, iocBoot_path):

        initIOC_print('Collecting additional iocBoot files from bundle...')
        for file in os.listdir(iocBoot_path):
            target = initIOC_path_join(iocBoot_path, file)
            if os.path.isfile(target):
                if file == 'auto_settings.req':
                    if not self.use_links:
                        shutil.copyfile(target, initIOC_path_join(ioc_path, file))
                    else:
                        os.symlink(target, initIOC_path_join(ioc_path, file))
                elif self.with_deps and not file.startswith(('Makefile', 'st', 'test', 'READ', 'dll', 'envPaths')):
                    shutil.copyfile(target, initIOC_path_join(ioc_path, file))


    def create_ioc_from_template(self, action, executable_path):

        ioc_path = initIOC_path_join(self.ioc_top, action.ioc_name)

        # First, clone the template:
        out = subprocess.call(["git", "clone", "--quiet", "https://github.com/epicsNSLS2-deploy/ioc-template", ioc_path])
        if out != 0:
            initIOC_print('ERROR - Failed to clone IOC template, aborting...')
        else:
            initIOC_print('Generating IOC from ioc-template (https://github.com/epicsNSLS2-deploy/ioc-temlpate)')
            os.remove(initIOC_path_join(ioc_path, 'st.cmd'))
            os.remove(initIOC_path_join(ioc_path, 'unique.cmd'))
            os.remove(initIOC_path_join(ioc_path, 'envPaths'))
            os.remove(initIOC_path_join(ioc_path, 'config'))
            startup_scripts = initIOC_path_join(ioc_path, 'startupScripts')
            self.genertate_st_cmd(action, executable_path, initIOC_path_join(startup_scripts, '{}St.cmd'.format(action.basename)))
            self.generate_unique_cmd(action)
            self.generate_env_paths(ioc_path, action)
            
            autosave_file_path = initIOC_path_join(ioc_path, 'autosaveFiles')
            dep_file_path = initIOC_path_join(ioc_path, 'dependancyFiles')
            for file in os.listdir(autosave_file_path):
                if file.startswith(action.basename):
                    shutil.copyfile(initIOC_path_join(autosave_file_path, file), initIOC_path_join(ioc_path, 'auto_settings.req'))
            for file in os.listdir(dep_file_path):
                if file.startswith(action.basename):
                    shutil.copyfile(initIOC_path_join(dep_file_path, file), initIOC_path_join(ioc_path, file.split('{}_'.format(action.basename))))
                    self.fix_macros(initIOC_path_join(ioc_path, file.split('{}_'.format(action.basename))), action)

            self.cleanup_template(action, ioc_path)


    def fix_macros(self, file_path, action):
        """
        Function that replaces certain macros in given filepath (used primarily for substitution files)

        Parameters
        ----------
        file_path : str
            path to the target file
        """

        os.rename(file_path, file_path + '_OLD')
        old = open(file_path+'_OLD', 'r')
        contents = old.read()
        contents = contents.replace('$(PREFIX)', action.ioc_prefix)
        contents = contents.replace('$(PORT)', action.asyn_port)
        new = open(file_path, 'w')
        new.write(contents)
        old.close()
        new.close()
        os.remove(file_path+'_OLD')


    def cleanup_template(self, action, ioc_path):

        initIOC_print('Performing cleanup for {}'.format(action.ioc_name))
        try:
            if platform == "win32":
                cleanup_script = initIOC_path_join(ioc_path, 'cleanup.bat')
                _ = subprocess.call([cleanup_script])
            else:
                cleanup_script = initIOC_path_join(ioc_path, 'cleanup.sh')
                _ = subprocess.call(['bash', cleanup_script])

            os.remove(cleanup_script)
        except:
            pass


class IOCAction:
    """Helper class that stores information and functions for each IOC in the CONFIGURE file

    Attributes
    ----------
    ioc_type : str
        name of areaDetector driver instance the IOC is linked to ex. ADProsilica
    ioc_name : str
        name of the IOC ex. cam-ps1
    ioc_prefix : str
        Prefix used by the IOC
    asyn_port : str
        asyn port used for outputting NDArrays
    ioc_port : str
        telnet port on which procserver will run the IOC
    connection : str
        Value used to connect to the device ex. IP, serial num. etc.
    ioc_num : int
        Counter that keeps track of which IOC it is
    """


    def __init__(self, ioc_type, ioc_name, bl_prefix, ioc_prefix, asyn_port, ioc_port, connection):
        """Constructor for the IOCAction class
        """

        self.epics_environment  = {}
        self.ioc_type           = ioc_type
        self.basename           = ioc_type[2:].lower()

        # These epics environment variables are set by the user for each IOC
        self.user_entered_env = ['ENGINEER', 'PORT', 'IOC', 'CAM-CONNECT', 'PREFIX', 'CTPREFIX', 'HOSTNAME', 'IOCNAME']
        
        self.asyn_port          = asyn_port
        self.epics_environment['PORT']      = asyn_port
        self.epics_environment['IOC']       = 'ioc{}'.format(ioc_type)
        self.epics_environment['EPICS_CA_AUTO_ADDR_LIST']   = 'NO'
        self.epics_environment['EPICS_CA_ADDR_LIST']        = "NA"
        self.epics_environment['EPICS_CA_MAX_ARRAY_BYTES']  = "6000000" 
        
        self.connection         = connection
        
        self.ioc_prefix         = ioc_prefix
        self.epics_environment['PREFIX']    = '{}{}'.format(bl_prefix, ioc_prefix)
        self.epics_environment['CTPREFIX']  = '{}{}'.format(bl_prefix, ioc_prefix)
        
        self.ioc_port           = ioc_port
        self.ioc_name           = ioc_name
        self.epics_environment['IOCNAME'] = ioc_name


    def add_to_environment(self, line):
        line_s = line.strip()
        line_s = re.sub('"', '', line_s)
        line_s = re.sub('\t', '', line_s)
        line_s = re.sub(' +', '', line_s)
        line_s = re.sub('epicsEnvSet', '', line_s)
        temp = line_s.split(',')
        if temp[0][1:] not in self.user_entered_env:
            self.epics_environment[temp[0][1:]] = temp[1][:-1]
        if self.ioc_type in existing_connection_parameter.keys():
            if existing_connection_parameter[self.ioc_type] == temp[1][:-1]:
                self.epics_environment[temp[0][1:]] = self.connection



#-------------------------------------------------
#----------------MAIN SCRIPT FUNCTIONS------------
#-------------------------------------------------


def parse_line_into_action(line, bl_prefix):
    """Function that parses a line in the CONFIGURE table into an IOCAction object

    Parameters
    ----------
    line : str
        The line to parse from the table
    ioc_num_counter : int
        the ioc counter
    
    Returns
    -------
    ioc_action : IOCAction
        the IOCAction object that contains information from line or None if it cannot successfully be parsed
    """

    try:
        line = line.strip()
        line = re.sub('\t', ' ', line)
        line = re.sub(' +', ' ', line)
        temp = line.split(' ')
        ioc_action = IOCAction(temp[0], temp[1], bl_prefix, temp[2], temp[3], temp[4], temp[5])
        return ioc_action
    except IndexError:
        initIOC_print('IOC line could not be parsed, skipping...')
        return None


def read_ioc_config():
    """Function for reading the CONFIGURE file. 
    
    Returns a dictionary of configure options, a list of IOCAction instances, 
    and a boolean representing if binaries are flat or not

    Returns
    -------
    ioc_actions : List of IOCAction
        list of IOC actions that need to be performed.
    configuration : dict of str -> str
        Dictionary containing all options read from configure
    """

    if not os.path.exists("CONFIGURE"):
        
        initIOC_print('\nCONFIGURE file not found, attempting to generate one.')
        if not os.access('.', os.W_OK):
            initIOC_print('ERROR! - Cannot create CONFIGURE file, insufficient permissions.\nAborting...')
            return
        try:
            enter_config_info()
            initIOC_print("CONFIGURE file generated. Add IOCs to the table, and rerun ./initIOCs.py -c.")
            return
        except PermissionError:
            initIOC_print("No write permissions in {}. Exiting...".format(os.getcwd()))
            return

    ioc_config_file = open("CONFIGURE", "r")
    ioc_actions = []
    configuration = {}
    ioc_num_counter = 1

    line = ioc_config_file.readline()
    while line:
        if "=" in line and not line.startswith('#') and 'BINARIES_FLAT' not in line:
            line = line.strip()
            split = line.split('=')
            configuration[split[0]] = split[1]
        elif not line.startswith('#') and len(line) > 1:
            ioc_action = parse_line_into_action(line, configuration['PREFIX'])
            if ioc_action is not None:
                ioc_num_counter = ioc_num_counter + 1
                ioc_actions.append(ioc_action)

        line = ioc_config_file.readline()

    ioc_config_file.close()
    return ioc_actions, configuration


def print_start_message():
    """Function for printing initial message
    """

    initIOC_print("+----------------------------------------------------------------+")
    initIOC_print("+ initIOCs, Version: " + __version__ +"                                      +")
    initIOC_print("+ Python Version: {}, OS platform: {:<27}+".format(sys.version.split()[0], platform))
    initIOC_print("+ Copyright (c): Brookhaven National Laboratory 2018-2019        +")
    initIOC_print("+ This software comes with NO warranty!                          +")
    initIOC_print("+----------------------------------------------------------------+")
    initIOC_print('')


def print_supported_drivers():
    """Function that prints list of supported drivers
    """

    initIOC_print('Supported Drivers:')
    initIOC_print("+-----------------------------+")
    for driver in supported_drivers:
        initIOC_print('+ {}'.format(driver))
    initIOC_print('')


def prompt_for_top_dirs(with_welcome=True):
    """Function that asks user for target IOC and binary locations.

    Parameters
    ----------
    with_welcome : bool
        If true, print welcome message
    """

    ioc_top = ''
    binaries_top = ''
    if with_welcome:
        print_start_message()
        initIOC_print('Welcome to initIOC!')
    valid = False
    while not valid:
        ioc_top        = input('Enter the ioc output location. > ')
        if not os.path.exists(os.path.dirname(ioc_top)):
            initIOC_print('\nThe selected ioc output directory does not exist, please try again.\n')
        elif os.path.isdir(ioc_top) and not os.access(ioc_top, os.W_OK):
            initIOC_print('\nThe selected output directory exists, but you do not have required permissions.\n')
        elif not os.access(os.path.dirname(ioc_top), os.W_OK):
            initIOC_print('\nYou do not have permission to generate the IOC output directory.\n')
        else:
            valid = True
    
    valid = False
    while not valid:
        binaries_top = input('Enter the location of your compiled binaries. > ')
        if not os.path.exists(binaries_top):
            initIOC_print('\nThe selected top binary directory does not exist, please try again.\n')
        else:
            ret = search_bundle_for_drivers(binaries_top)
            if not ret:
                initIOC_print('Please enter a binary location that includes compiled drivers.\n')
            else:
                initIOC_print('')
                valid = True

    return ioc_top, os.path.abspath(binaries_top)


def enter_config_info():
    initIOC_print('Please enter all pertinent information.\n')
    ioc_top, bin_top = prompt_for_top_dirs(with_welcome=False)
    configuration = {}
    configuration['IOC_DIR'] = ioc_top
    configuration['TOP_BINARY_DIR'] = bin_top
    configuration['PREFIX']          = input('Enter the Beamline Prefix (without the camera specific portion ex. XF:10IDC-BI).\n> ')
    configuration['HOSTNAME']        = input('Enter the IOC server hostname.\n> ')
    configuration['ENGINEER']        = input('Enter your name and contact information.\n> ')
    configuration['CA_ADDRESS']      = input('Enter the Channel Address subnet IP.\n> ')
    write_config(configuration)


def write_config(configuration):
    if os.path.exists('CONFIGURE'):
        os.remove('CONFIGURE')
    file = open('CONFIGURE', 'w')
    file.write('#\n# initIOCs CONFIGURE file autogenerated on {}\n#\n\n'.format(datetime.datetime.now()))
    for elem in configuration.keys():
        file.write('# {}\n'.format(config_tooltips[elem]))
        file.write('{}={}\n\n'.format(elem, configuration[elem]))

    file.write('# IOC Type        IOC Name     Asyn Port      IOC Port      Cam Connection\n')
    file.write('#-------------------------------------------------------------------------\n')
    file.close()


def guided_init_iocs(manager):
    """Function that guides the user through generating a single IOC through the CLI
    """
    
    bl_prefix       = input('Enter the IOC Prefix (without the camera specific portion ex. XF:10IDC-BI).\n> ')
    hostname        = input('Enter the IOC server hostname.\n> ')
    engineer        = input('Enter your name and contact information.\n> ')
    ca_address_ip   = input('Enter the Channel Address subnet IP.\n> ')

    another_ioc = True
    while another_ioc:
        driver_type = None
        while driver_type is None:
            driver_type = input('What driver type would you like to generate?\n> ')
            if driver_type not in supported_drivers and manager.use_template:
                driver_type = None
                initIOC_print('The selected driver does not have a template. See list of supported drivers below.')
                print_supported_drivers()
                initIOC_print('You may alternatively try to generate from sources (without the -t flag).')
            if driver_type is not None and not os.path.exists(os.path.join(manager.areaDetector_path, driver_type)):
                initIOC_print('Could not find driver {} in {}.'.format(driver_type, os.path.join(manager.areaDetector_path, driver_type)))
                driver_type = None

        # Ask for IOC name
        valid = False
        while not valid:
            ioc_name = input('What should the IOC name be?\n> ')
            if os.path.exists(initIOC_path_join(manager.ioc_top, ioc_name)):
                initIOC_print('\nIOC with name {} already exists!\n'.format(ioc_name))
            else:
                valid = True

        # Ask for camera specific information
        dev_prefix  = input('Please enter the device specific portion of the PV prefix (ex. {BlackFly-Cam:1})\n> ')
        asyn_port   = input('What asyn port should the IOC use? (ex. PS1).\n> ')
        ioc_port    = input('What telnet port should procServer use to run the IOC? (ex. 4000)\n> ')
        connection  = input('Enter the connection parameter for your device. (ex. IP, serial number etc.) Enter NA if not sure.\n> ')
        
        # Generate a Data model IOCAction object, and initialize its environment.
        ioc_action = IOCAction(driver_type, ioc_name, bl_prefix, dev_prefix, asyn_port, ioc_port, connection)
        ioc_action.epics_environment['HOSTNAME']            = hostname
        ioc_action.epics_environment['ENGINEER']            = engineer
        ioc_action.epics_environment['EPICS_CA_ADDR_LIST']  = ca_address_ip

        # Execute the action
        manager.process_action(ioc_action)
        another = input('Would you like to generate another IOC? (y/n).\n> ')
        if another != 'y':
            another_ioc = False

    initIOC_print('Exiting...')


def init_iocs_cli(actions, manager):
    """Drives IOC generation from CONFIGURE file

    Parameters
    ----------
    actions : list of IOCAction
        list of IOC actions to perform
    manager : IOCActionManger
        Manager object for executing IOC actions
    """

    if len(actions) == 0:
        initIOC_print('No IOCs detected in table.')
    for action in actions:
        if action.ioc_type not in supported_drivers and manager.use_template:
            initIOC_print('ERROR - {} does not currently have a template!'.format(action.ioc_type))
            print_supported_drivers()
            initIOC_print('To request support for {} to be added to initIOC, please create an issue on:'.format(action.ioc_type))
            initIOC_print('https://github.com/epicsNSLS2-deploy/initIOC/issues\n')
            initIOC_print('Alternatively, you may try using the non-templated version. (Run without "-t" flag)')
        else:
            manager.process_action(action)


def initIOC_print(text):
    """A wrapper function for 'print' that allows for printing to CLI or to log

    Parameters
    ----------
    text : str
        Text to print to console of log
    """

    if USING_GUI and GUI_TOP_WINDOW is not None:
        GUI_TOP_WINDOW.writeToLog(text + '\n')
    else:
        print(text)


def parse_args():
    """Function that parses the command line arguments
    """

    parser = argparse.ArgumentParser(description='A script for auto-initializing areaDetector IOCs. Edit the CONFIGURE file and run without arguments for default operation.')

    parser.add_argument('-c', '--configure',        action='store_true', help='Add this flag to use a run initIOCs given a CONFIGURE file.')
    parser.add_argument('-p', '--setlibrarypath',   action='store_true', help='This flag should be added to set library path before startup script is run.')
    parser.add_argument('-t', '--template',         action='store_true', help='This flag will tell initIOC to use an st.cmd template. These are more likely to process without error, but may be somewhat out of date.')
    parser.add_argument('-l', '--links',            action='store_true', help='Add this flag if you would like initIOC to create copies of required helper files instead of links.')
    parser.add_argument('-m', '--minimal',          action='store_true', help='This flag specifies if initIOC should attempt to generate a minimal IOC. May result in some missing files that will need manual tweaks.')
    parser.add_argument('-s', '--searchbundle',     help='Add this flag, followed by a path to a binary bundle to get a list of driver executables that are included.')
    arguments = vars(parser.parse_args())
    return arguments


def search_bundle_for_drivers(bin_top):
    initIOC_print('\nBundle selected: {}'.format(bin_top))
    manager = IOCActionManager('.', bin_top, False, False, False, False)
    initIOC_print('List of detected driver executables:\n+-----------------------------------------------')
    if not os.path.exists(manager.areaDetector_path):
        initIOC_print('ERROR - No binaries found in location {}\n'.format(bin_top))
        return False
    for dir in os.listdir(manager.areaDetector_path):
        if os.path.isdir(os.path.join(manager.areaDetector_path, dir)):
            action = IOCAction(dir, '', '', '', '', '', 0)
            _, bin_path, _ = manager.find_paths_for_action(action)
            if bin_path is not None:
                initIOC_print('+ {:<16} -   {}'.format(dir, bin_path))
    return True


# Run the script
def main():

    try:
    
        arguments = parse_args()

        global USING_GUI
        global GUI_TOP_WINDOW

        if arguments['searchbundle'] is not None:
            initIOC_print('\nSearching for driver executables...\n')
            bin_top = arguments['searchbundle']
            if not os.path.exists(bin_top):
                initIOC_print('Selected bundle location does not exist.')
            else:
                _ = search_bundle_for_drivers(bin_top)
            initIOC_print('')
            exit()

        if arguments['configure']:
            actions, configuration = read_ioc_config()
            manager = IOCActionManager(configuration['IOC_DIR'], configuration['TOP_BINARY_DIR'], arguments['setlibrarypath'], arguments['template'], not arguments['minimal'], arguments['links'])
            for action in actions:
                # Add parameters to environment variables
                action.epics_environment['ENGINEER'] = configuration['ENGINEER']
                action.epics_environment['HOSTNAME'] = configuration['HOSTNAME']
                action.epics_environment['EPICS_CA_ADDR_LIST'] = configuration['CA_ADDRESS']

            else:
                print_start_message()
                if len(actions) == 0:
                    initIOC_print('No IOCs set for generation, please edit the CONFIGURE file.')
                    exit()
                init_iocs_cli(actions, manager)
        else:
            ioc_top, bin_top = prompt_for_top_dirs()
            manager = IOCActionManager(ioc_top, bin_top, arguments['setlibrarypath'], arguments['template'], not arguments['minimal'], arguments['links'])
            guided_init_iocs( manager)

    except KeyboardInterrupt:
        initIOC_print('\n\nExiting...')
        exit()


if __name__ == '__main__':
    main()





